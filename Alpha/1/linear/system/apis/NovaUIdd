--[[type="executable_package", name="NovaUI"]]
local files = {["Thread"]={content="\
\
local threads = { }\
\
Thread.public \"environment\"\
function Thread.public.environment:read( )\
	return self.env\
end\
function Thread.public.environment:write( value )\
	if type( value ) ~= \"table\" then\
		error( \"expected table\", 3 )\
	end\
	self.env = value\
end\
\
Thread.public \"onException\" \"function\"\
Thread.public \"onFinish\" \"function\"\
\
function Thread:Thread( thread )\
	self.state = \"running\"\
	self.thread = thread\
	self.env = setmetatable( { wait = coroutine.yield, thread = self.public }, { __index = getfenv( ) } )\
	setfenv( self.thread, setmetatable( { }, { __index = function( _, k ) return self.env[k] end, __newindex = function( _, k, v ) self.env[k] = v end } ) )\
	self.co = coroutine.create( thread )\
\
	table.insert( threads, self.public )\
\
	return self.public\
end\
\
function Thread.public:pause( )\
	if self.state == \"running\" then\
		self.state = \"paused\"\
		return true\
	end\
	return false\
end\
\
function Thread.public:resume( )\
	if self.state == \"paused\" then\
		self.state = \"running\"\
		return true\
	end\
	return false\
end\
\
function Thread.public:restart( )\
	self.co = coroutine.create( self.thread )\
	self.state = \"running\"\
end\
\
function Thread.public:stop( )\
	self.state = \"stopped\"\
end\
\
function Thread.public:isRunning( )\
	return self.state == \"running\"\
end\
\
function Thread.public:isPaused( )\
	return self.state == \"paused\"\
end\
\
function Thread.public:update( args )\
	if self.state == \"stopped\" then\
		return false, \"finished\"\
	end\
	if self.state ~= \"running\" then\
		return false, \"not running\"\
	end\
	local ok, data = coroutine.resume( self.co, unpack( args ) )\
	if not ok then\
		self.state = \"stopped\"\
		if type( self.onException ) == \"function\" then\
			pcall( self.onException, self.public, data )\
		end\
		if self.state == \"stopped\" then\
			return false, \"finished\"\
		end\
		return false, \"errored\"\
	end\
	if coroutine.status( self.co ) == \"dead\" then -- give it a chance to restart\
		if type( self.onFinish ) == \"function\" then\
			pcall( self.onFinish, self.public )\
		end\
	end\
	if coroutine.status( self.co ) == \"dead\" then\
		self.state = \"stopped\"\
		return false, \"finished\"\
	end\
	return true, data\
end\
\
function Thread.static.update( args )\
	for i = #threads, 1, -1 do\
		local ok, data = threads[i]:update( args )\
		if not ok and data == \"finished\" then\
			table.remove( threads, i )\
		end\
	end\
end", meta={
  type = "class",
}};["UIButton"]={content="\
\
require \"UIElement\"\
\
UIButton:extends( UIElement )\
\
UIButton.text = \"\"\
UIButton.public \"text\"\
\
UIButton.public \"bc\" \"number\"\
UIButton.public \"tc\" \"number\"\
\
UIButton.onClick = false\
UIButton.public \"onClick\" \"function\"\
UIButton.onDrag = false\
UIButton.public \"onDrag\" \"function\"\
\
UIButton.align = true\
UIButton.public \"align\" \"boolean\"\
\
UIButton.handlesEnter = true\
\
function UIButton:UIButton( x, y, w, h, text )\
	self:UIElement( x, y, w, h )\
	self.text = text\
	self.bc = colours.white\
	self.tc = colours.blue\
	return self.public\
end\
\
function UIButton.public:draw( x, y )\
	local layer = stencil.addLayer( x, y, self.w, self.h )\
	local text = tostring( self.text )\
	if type( self.text ) == \"function\" then\
		text = self.text( self.public )\
	end\
	if self.align then\
		stencil.text( x, y, self.w, self.h, self.bc, self.tc, text, function( lines )\
			while #lines < self.h do\
				table.insert( lines, 1, string.rep( \" \", self.w ) )\
				table.insert( lines, string.rep( \" \", self.w ) )\
			end\
			if #lines > self.h then\
				table.remove( lines, 1 )\
			end\
			for i = 1, #lines do\
				lines[i] = string.rep( \" \", math.floor( ( self.w - #lines[i] ) / 2 ) ) .. lines[i]\
			end\
		end )\
	else\
		stencil.text( x, y, self.w, self.h, self.bc, self.tc, text )\
	end\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:draw( x + child.x - 1 + self.cx, y + child.y - 1 + self.cy )\
	end\
	stencil.closeLayer( layer )\
end\
\
function UIButton.public:onMouseClick( rx, ry, button )\
	if self.onClick then\
		self.onClick( self.public, rx, ry, button )\
	end\
end\
\
function UIButton.public:onMouseDrag( x, y, cx, cy, button )\
	if self.onDrag then\
		self.onDrag( self.public, x, y, cx, cy, button )\
	end\
end\
\
function UIButton.public:onKeyPress( key )\
	if key == keys.enter and self.onClick then\
		self.onClick( self.public, 1, 1, \"enter\" )\
	end\
end", meta={
  type = "class",
}};["UIImage"]={content="\
\
require \"Image\"\
require \"UIElement\"\
\
UIImage.public \"image\" (Image)\
UIImage.public \"onClick\" \"function\"\
UIImage.public \"onDrag\" \"function\"\
UIImage.public \"onScroll\" \"function\"\
\
UIImage:extends( UIElement )\
\
function UIImage:UIImage( x, y, w, h, image ) -- Image object\
	self:UIElement( x, y, w, h )\
	self.image = image\
	return self.public\
end\
\
function UIImage.public:draw( x, y )\
	local layer = stencil.addLayer( x, y, self.w, self.h )\
	for xx = 1, self.w do\
		for yy = 1, self.h do\
			local bc, tc, char = self.image:getPixel( xx, yy )\
			if bc then\
				if bc ~= 0 or char ~= \" \" then\
					stencil.pixel( x + xx - 1, y + yy - 1, bc, tc, char )\
				end\
			end\
		end\
	end\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:draw( x + child.x - 1 + self.cx, y + child.y - 1 + self.cy )\
	end\
	stencil.closeLayer( layer )\
end\
\
function UIImage.public:onMouseClick( rx, ry, button )\
	if self.onClick then\
		self.onClick( self.public, rx, ry, button )\
	end\
end\
\
function UIImage.public:onMouseDrag( rx, ry, cx, cy, button )\
	if self.onDrag then\
		self.onDrag( self.public, rx, ry, cx, cy, button )\
	end\
end\
\
function UIImage.public:onMouseScroll( rx, ry, dir )\
	if self.onScroll then\
		self.onScroll( self.public, rx, ry, dir )\
	end\
end", meta={
  type = "class",
}};["display"]={content="\
\
local function bluebox( frame, height )\
	local w, h = frame.w, frame.h\
	local f = frame:newChild( UIFrame( 1, math.ceil( h / 2 - height / 2 ) + 1, w, height ) )\
	f:newChild( UIText( 1, 1, f.w, f.h, \"\" ) ).bc = colours.blue\
	return f\
end\
\
function alert( frame, message, wait )\
	local active = true\
	local close = frame:newChild( UIButton( 1, 1, frame.w, frame.h, \"\" ) )\
	close.bc = 0\
	close.align = false\
	local f = bluebox( frame, 5 )\
	function close:onClick( )\
		close:remove( )\
		f:remove( )\
		active = false\
	end\
	local title = f:newChild( UIText( 0, 2, #message, 1, message ) )\
	title.bc = 0\
	title.tc = colours.lightBlue\
	title:centreX( )\
	local ok = f:newChild( UIButton( 0, 4, 2, 1, \"ok\" ) )\
	ok.bc = 0\
	ok.tc = colours.white\
	ok:centreX( )\
	function ok:onClick( )\
		close:remove( )\
		f:remove( )\
		active = false\
	end\
	if wait then\
		while active do\
			coroutine.yield( )\
		end\
	end\
end\
\
function response( frame, title )\
	local active = true\
	local r = false\
	local close = frame:newChild( UIButton( 1, 1, frame.w, frame.h, \"\" ) )\
	close.bc = 0\
	close.align = false\
	local f = bluebox( frame, 5 )\
	function close:onClick( )\
		close:remove( )\
		f:remove( )\
		active = false\
	end\
	local title = f:newChild( UIText( 0, 2, #title, 1, title ) )\
	title.bc = 0\
	title.tc = colours.lightBlue\
	title:centreX( )\
	local input = f:newChild( UIInput( 2, 4, frame.w - 2, 1 ) )\
	input.bc = 0\
	input.fbc = 0\
	input.tc = colours.white\
	input:focusOn( )\
	function input:onEnter( )\
		close:remove( )\
		f:remove( )\
		active = false\
		r = self.text\
	end\
	while active do\
		coroutine.yield( )\
	end\
	return r\
end\
\
function confirm( frame, title )\
	local result = \"none\"\
	local close = frame:newChild( UIButton( 1, 1, frame.w, frame.h, \"\" ) )\
	close.bc = 0\
	close.align = false\
	local f = bluebox( frame, 5 )\
	function close:onClick( )\
		close:remove( )\
		f:remove( )\
		result = nil\
	end\
	local t = f:newChild( UIText( 2, 2, f.w - 2, 1, title ) )\
	t.bc = colours.blue\
	t.tc = colours.lightBlue\
	local yes = f:newChild( UIButton( 2, 4, math.floor( ( f.w - 2 ) / 2 ), 1, \"yes\" ) )\
	yes.bc = colours.blue\
	yes.tc = colours.white\
	function yes:onClick( )\
		f:remove( )\
		close:remove( )\
		result = true\
	end\
	local no = f:newChild( UIButton( f.w - yes.w, 4, math.floor( ( f.w - 2 ) / 2 ), 1, \"no\" ) )\
	no.bc = colours.blue\
	no.tc = colours.white\
	function no:onClick( )\
		f:remove( )\
		close:remove( )\
		result = false\
	end\
	while result == \"none\" do\
		coroutine.yield( )\
	end\
	return result\
end\
\
function sframe( frame, x, y, w, h ) -- scrolling frame (auto scrollbar)\
\
end\
\
function help( frame, title, content )\
	local close = frame:newChild( UIButton( 1, 1, frame.w, frame.h, \"\" ) )\
	close.bc = 0\
	close.align = false\
	local f = bluebox( frame, 14 )\
	local t = f:newChild( UIText( 2, 2, #title, 1, title ) )\
	t.bc = colours.blue\
	t.tc = colours.white\
	t:centreX( )\
	f:newChild( UIText( 3, 5, f.w - 3, f.h - 7, \"\" ) ).bc = colours.grey\
	local c = f:newChild( UIText( 2, 4, f.w - 3, f.h - 7, content ) )\
	c.tc = colours.grey\
	local ok = f:newChild( UIButton( 2, f.h - 1, f.w - 2, 1, \"Got it!\" ) )\
	ok.bc = colours.blue\
	ok.tc = colours.white\
	function ok:onClick( )\
		close:remove( )\
		f:remove( )\
	end\
	function close:onClick( )\
		close:remove( )\
		f:remove( )\
	end\
end\
\
function menu( frame, options )\
	frame:clearChildren( )\
	if options.width then\
		frame.w = options.width\
	end\
	if options.height then\
		frame.h = options.height\
	end\
	if options.shadow then\
		frame.w = frame.w - 1\
		frame.h = frame.h - 1\
		frame:newChild( UIText( 2, 2, frame.w, frame.h, \"\" ) ).bc = options.shadow\
	end\
	local sframe = frame\
	local y = 1\
	local bc = options.colour or 1\
	frame:newChild( UIButton( 1, 1, frame.w, frame.h, \"\" ) ).bc = bc\
	if #options > frame.h then\
		sframe = frame:newChild( UIFrame( 1, 1, frame.w - 1, frame.h ) )\
		local scrollbar = frame:newChild( UIScrollBar( frame.w, 1, 1, frame.h, sframe ) )\
	end\
	for i = 1, #options do\
		if options[i] == \"rule\" then\
			local r = sframe:newChild( UIText( 2, y, sframe.w - 2, 1, (\"-\"):rep( math.max( sframe.w - 2, 0 ) ) ) )\
			r.tc = colours.lightGrey\
			r.bc = 0\
		elseif options[i] ~= \"space\" then\
			if options[i].type == \"menu\" then\
				local arrow = sframe:newChild( UIText( sframe.w - 1, y, 1, 1, \">\" ) )\
				arrow.bc = 0\
				arrow.tc = colours.blue\
				local button = sframe:newChild( UIButton( options.spacing == false and 2 or 3, y, sframe.w - ( options.spacing == false and 2 or 3 ), 1, options[i].name ) )\
				button.bc = 0\
				button.tc = colours.grey\
				button.align = false\
				local cx, cy = frame.x + frame.w, y - 1\
				function button:onClick( )\
					if frame.parent then\
						local close = frame:newChild( UIButton( 1, 1, frame.w, frame.h, \"\" ) )\
						close.bc, close.align = 0, false\
						local f = UIFrame( cx, cy + frame.y + sframe.cy, frame.w, frame.h )\
						local w, h = frame.parent.w, frame.parent.h\
						menu( f, options[i].options )\
						if f.x + f.w > w + 1 then\
							f.x = w - f.w + 1\
						end\
						if f.y + f.h > h + 1 then\
							f.y = h - f.h + 1\
						end\
						frame.parent:newChild( f )\
						function close:onClick( )\
							f:remove( )\
							close:remove( )\
						end\
					end\
				end\
			elseif options[i].type == \"button\" then\
				local button = sframe:newChild( UIButton( options.spacing == false and 2 or 4, y, sframe.w - ( options.spacing == false and 2 or 4 ), 1, options[i].name ) )\
				button.bc = 0\
				button.tc = colours.grey\
				button.align = false\
				function button:onClick( x, y, b )\
					if type( options[i].onClick ) == \"function\" then\
						options[i].onClick( button, frame, b )\
					end\
				end\
			elseif options[i].type == \"display\" then\
				local text = sframe:newChild( UIText( options.spacing == false and 2 or 4, y, sframe.w - ( options.spacing == false and 2 or 4 ), 1, function( )\
					if type( options[i].getDisplay ) == \"function\" then\
						return options[i].name .. tostring( options[i].getDisplay( ) )\
					end\
					return options[i].name\
				end ) )\
				text.bc = 0\
				text.tc = colours.grey\
			elseif options[i].type == \"input\" then\
\
			elseif options[i].type == \"label\" then\
				local text = sframe:newChild( UIText( 2, y, sframe.w - 2, 1, options[i].name ) )\
				text.bc = 0\
				text.tc = colours.lightGrey\
			end\
		end\
		y = y + 1\
	end\
	if options.shadow then\
		frame.w = frame.w + 1\
		frame.h = frame.h + 1\
	end\
	return sframe\
end", meta={
  type = "lib",
}};["UIElement"]={content="\
\
require \"UIHandler\"\
\
UIElement.public \"x\" \"number\"\
UIElement.public \"y\" \"number\"\
UIElement.public \"w\" \"number\"\
UIElement.public \"h\" \"number\"\
UIElement.public \"cx\" \"number\"\
UIElement.public \"cy\" \"number\"\
\
UIElement.public \"parent\"\
function UIElement.public.parent:write( value )\
	if value == false or class.typeOf( value, UIElement ) or class.typeOf( value, UIHandler ) then\
		self.parent = value\
	else\
		error( \"expected UIElement parent\", 3 )\
	end\
end\
\
UIElement.handlesMouse = true\
UIElement.handlesScroll = false\
UIElement.handlesTab = false\
UIElement.tabIndex = false\
\
UIElement.public \"handlesMouse\"\
UIElement.public.handlesMouse.write = false\
UIElement.public \"handlesKeys\"\
UIElement.public.handlesKeys.write = false\
UIElement.public \"handlesScroll\"\
UIElement.public.handlesScroll.write = false\
UIElement.public \"handlesTab\"\
UIElement.public.handlesTab.write = false\
UIElement.public \"handlesEnter\"\
UIElement.public.handlesEnter.write = false\
UIElement.public \"tabIndex\" \"boolean\"\
\
UIElement.isScrollTarget = false\
UIElement.public \"isScrollTarget\"\
UIElement.public.isScrollTarget.write = false\
UIElement.scrollDirection = \"none\"\
UIElement.public \"scrollDirection\"\
UIElement.public.scrollDirection.write = false\
\
UIElement.public \"whenFocussed\" \"function\"\
UIElement.public \"whenUnFocussed\" \"function\"\
\
function UIElement:UIElement( x, y, w, h )\
	self.x = x\
	self.y = y\
	self.w = w\
	self.h = h\
	self.cx = 0 -- children offset\
	self.cy = 0\
	self.children = { }\
	return self.public\
end\
\
-- children\
\
function UIElement.public:newChild( child )\
	if class.typeOf( child, UIElement ) then\
		table.insert( self.children, child )\
		child.parent = self.public\
		return child\
	else\
		error( \"expected UIElement child\", 2 )\
	end\
end\
\
function UIElement.public:removeChild( child )\
	if class.typeOf( child, UIElement ) then\
		for i = 1, #self.children do\
			if self.children[i] == child then\
				table.remove( self.children, i )\
				return true\
			end\
		end\
		return false\
	else\
		error( \"expected UIElement child\", 3 )\
	end\
end\
\
function UIElement.public:getChildren( )\
	local t = { }\
	for i = 1, #self.children do\
		t[i] = self.children[i]\
	end\
	return t\
end\
\
function UIElement.public:clearChildren( )\
	for i = #self.children, 1, -1 do\
		self.children[i]:remove( )\
	end\
end\
\
local function merge( t1, t2 )\
	local t = { }\
	for i, v in ipairs( t1 ) do\
		table.insert( t, v )\
	end\
	for i, v in ipairs( t2 ) do\
		table.insert( t, v )\
	end\
	return t\
end\
\
function UIElement.public:getTabIndexes( )\
	local t = { }\
	if self.tabIndex then\
		table.insert( t, self.public )\
	end\
	for i = 1, #self.children do\
		local t2 = self.children[i]:getTabIndexes( )\
		if #t2 > 0 then\
			t = merge( t, t2 )\
		end\
	end\
	return t\
end\
\
-- parent dependant\
\
function UIElement.public:positionIn( parent )\
	local x, y = self.x, self.y\
	local p = self.parent\
	while p and p ~= parent and p:type( ) ~= \"UIHandler\" do\
		x = x + p.x\
		y = y + p.y\
		p = p.parent\
	end\
	return x, y\
end\
\
function UIElement.public:remove( )\
	if self.parent then\
		return self.parent:removeChild( self.public )\
	end\
	return false\
end\
\
function UIElement.public:getHandler( )\
	if self.parent then\
		local h = self.parent\
		while h:type( ) ~= \"UIHandler\" do\
			h = h.parent\
		end\
		return h\
	end\
	return false\
end\
\
function UIElement.public:centreX( )\
	if self.parent then\
		self.x = math.ceil( self.parent.w / 2 - self.w / 2 ) + 1\
	end\
	return self.public\
end\
\
function UIElement.public:centreY( )\
	if self.parent then\
		self.y = math.ceil( self.parent.h / 2 - self.h / 2 ) + 1\
	end\
	return self.public\
end\
\
function UIElement.public:centre( )\
	self.public:centreX( )\
	self.public:centreY( )\
end\
\
-- sibling dependant\
\
function UIElement.public:align( mode, sibling, spacing )\
	if mode == \"above\" then\
		self.x = sibling.x\
		self.w = sibling.w\
		self.y = sibling.y - self.h - ( spacing or 0 )\
	elseif mode == \"below\" then\
		self.x = sibling.x\
		self.w = sibling.w\
		self.y = sibling.y + sibling.h + ( spacing or 0 )\
	elseif mode == \"left\" then\
		self.y = sibling.y\
		self.h = sibling.h\
		self.x = sibling.x - self.w - ( spacing or 0 )\
	elseif mode == \"right\" then\
		self.y = sibling.y\
		self.h = sibling.h\
		self.x = sibling.x + sibling.w + ( spacing or 0 )\
	end\
	return self.public\
end\
\
function UIElement.public:alignTo( mode, sibling, spacing )\
	if mode == \"above\" then\
		self.x = sibling.x\
		self.w = sibling.w\
		self.y = sibling.y - self.h - ( spacing or 0 )\
	elseif mode == \"below\" then\
		self.x = sibling.x\
		self.w = sibling.w\
		self.y = sibling.y + sibling.h + ( spacing or 0 )\
	elseif mode == \"left\" then\
		self.y = sibling.y\
		self.h = sibling.h\
		self.x = sibling.x - self.w - ( spacing or 0 )\
	elseif mode == \"right\" then\
		self.y = sibling.y\
		self.h = sibling.h\
		self.x = sibling.x + sibling.w + ( spacing or 0 )\
	end\
	return self.public\
end\
\
-- callbacks\
\
function UIElement.public:update( dt )\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:update( dt )\
	end\
end\
\
function UIElement.public:draw( x, y )\
	local layer = stencil.addLayer( x, y, self.w, self.h )\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:draw( x + child.x - 1 + self.cx, y + child.y - 1 + self.cy )\
	end\
	stencil.closeLayer( layer )\
end\
\
function UIElement.public:onMouseClick( rx, ry, button )\
\
end\
\
function UIElement.public:onMouseDrag( rx, ry, cx, cy, button )\
\
end\
\
function UIElement.public:onMouseScroll( rx, ry, dir )\
\
end\
\
function UIElement.public:onKeyPress( key, lastkey )\
\
end\
\
function UIElement.public:onTextInput( text, lastkey )\
\
end\
\
function UIElement.public:onFocus( )\
	if type( self.whenFocussed ) == \"function\" then\
		self.whenFocussed( self.public )\
	end\
end\
\
function UIElement.public:onUnFocus( )\
	if type( self.whenUnFocussed ) == \"function\" then\
		self.whenUnFocussed( self.public )\
	end\
end", meta={
  type = "class",
}};["UIHandler"]={content="\
\
require \"stencil\"\
\
UIHandler.public.w, UIHandler.public.h = term.getSize( )\
\
UIHandler.public \"focus\"\
UIHandler.public.focus.write = false\
\
function UIHandler:UIHandler( )\
	self.children = { }\
	self.focus = false\
	self.lastx = 0\
	self.lasty = 0\
	self.lastt = false\
	self.lastkey = nil\
	self.lastkeytime = false\
	return self.public\
end\
\
function UIHandler.public:draw( )\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:draw( child.x, child.y )\
	end\
end\
\
function UIHandler.public:update( dt )\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:update( dt )\
	end\
	if self.lastkeytime then\
		if os.clock( ) - self.lastkeytime > 0.3 then\
			self.lastkey = nil\
			self.lastkeytime = false\
		end\
	end\
end\
\
local function findMouseTarget( children, parent, handler, x, y )\
	x = x - parent.cx\
	y = y - parent.cy\
	for i = #children, 1, -1 do\
		local child = children[i]\
		if x >= child.x and y >= child.y and x < child.x + child.w and y < child.y + child.h then\
			local ok, c, data = findMouseTarget( child:getChildren( ), child, handler, x - child.x + 1, y - child.y + 1 )\
			if ok then\
				return true, c, data\
			end\
			local ok, data = handler( child, parent, x, y )\
			if ok then\
				return true, child, data\
			end\
		end\
	end\
	return false\
end\
\
local function screenCoords( child )\
	local x, y = child.x, child.y\
	while child.parent and child.parent:type( ) ~= \"UIHandler\" do -- everything but a UIHandler will have a parent\
		child = child.parent\
		x = x + child.x - 1 + child.cx\
		y = y + child.y - 1 + child.cy\
	end\
	return x, y\
end\
\
local function merge( t1, t2 )\
	local t = { }\
	for i, v in ipairs( t1 ) do\
		table.insert( t, v )\
	end\
	for i, v in ipairs( t2 ) do\
		table.insert( t, v )\
	end\
	return t\
end\
\
function UIHandler.public:event( event )\
	if event[1] == \"mouse_click\" then\
		self.lastx = event[3]\
		self.lasty = event[4]\
		local found, child, data = findMouseTarget( self.children, {cx=0, cy=0}, function( child, parent, x, y )\
			if child.handlesMouse then\
				return true, { rx = x - child.x + 1, ry = y - child.y + 1 }\
			end\
		end, event[3], event[4] )\
		if found then\
			if child ~= self.focus and self.focus then\
				self.focus:onUnFocus( )\
			end\
			if child ~= self.focus then\
				child:onFocus( )\
			end\
			self.focus = child\
			child:onMouseClick( data.rx, data.ry, event[2] )\
			self.lastt = child\
		else\
			self.lastt = false\
			if self.focus then\
				self.focus:onUnFocus( )\
			end\
			self.focus = false\
		end\
	elseif event[1] == \"mouse_scroll\" then\
		local found, child, data = findMouseTarget( self.children, {cx=0, cy=0}, function( child, parent, x, y )\
			if child.handlesScroll then\
				return true, { rx = x - child.x + 1, ry = y - child.y + 1 }\
			end\
		end, event[3], event[4] )\
		if found then\
			child:onMouseScroll( data.rx, data.ry, event[2] )\
		end\
	elseif event[1] == \"mouse_drag\" then\
		if self.lastt then\
			local cx, cy = event[3] - self.lastx, event[4] - self.lasty\
			local sx, sy = screenCoords( self.lastt )\
			self.lastt:onMouseDrag( event[3] - sx + 1, event[4] - sy + 1, cx, cy, event[2] )\
			self.lastx = event[3]\
			self.lasty = event[4]\
		end\
	elseif event[1] == \"key\" then\
		if event[2] == keys.tab then\
\
			if self.focus and self.focus.handlesTab then\
				self.focus:onKeyPress( keys.tab, self.lastkey )\
			else\
				local tabs = { }\
				for i = 1, #self.children do\
					local t2 = self.children[i]:getTabIndexes( )\
					if #t2 > 0 then\
						tabs = merge( tabs, t2 )\
					end\
				end\
				local of = self.focus\
				local found = false\
				for i = 1, #tabs do\
					if tabs[i] == self.focus then\
						if self.lastkey == keys.leftShift or self.lastkey == keys.rightShift then\
							if tabs[i-1] then\
								self.focus = tabs[i-1]\
							else\
								self.focus = tabs[#tabs]\
							end\
						else\
							if tabs[i+1] then\
								self.focus = tabs[i+1]\
							else\
								self.focus = tabs[1]\
							end\
						end\
						found = true\
						break\
					end\
				end\
				if not found then\
					self.focus = tabs[1]\
				end\
				if of ~= self.focus then\
					if of then\
						of:onUnFocus( )\
					end\
					if self.focus then\
						self.focus:onFocus( )\
					end\
				end\
			end\
		else\
			if self.focus and ( self.focus.handlesKeys or ( self.focus.handlesEnter and event[2] == keys.enter ) ) then\
				self.focus:onKeyPress( event[2], self.lastkey )\
			else\
				local function find( c )\
					for i = #c, 1, -1 do\
						local ok, obj = find( c[i]:getChildren( ) )\
						if ok then\
							return true, obj\
						end\
						if c[i].handlesKeys then\
							c[i]:onKeyPress( event[2], self.lastkey )\
							return true, c[i]\
						end\
					end\
				end\
				find( self.children )\
			end\
		end\
	elseif event[1] == \"char\" then\
		if self.focus and self.focus.handlesKeys then\
			self.focus:onTextInput( event[2], self.lastkey )\
		else\
			local function find( c )\
				for i = #c, 1, -1 do\
					local ok, obj = find( c[i]:getChildren( ) )\
					if ok then\
						return true, obj\
					end\
					if c[i].handlesKeys then\
						c[i]:onTextInput( event[2], self.lastkey )\
						return true, c[i]\
					end\
				end\
			end\
			find( self.children )\
		end\
	end\
	if event[1] == \"key\" or ( event[1] == \"char\" and self.lastkey ) then\
		if event[1] == \"key\" then\
			self.lastkey = event[2]\
		end\
		self.lastkeytime = os.clock( )\
	else\
		self.lastkey = nil\
		self.lastkeytime = false\
	end\
end\
\
function UIHandler.public:newChild( child )\
	if class.typeOf( child, UIElement ) then\
		table.insert( self.children, child )\
		child.parent = self.public\
		return child\
	else\
		error( \"expected UIElement child\", 2 )\
	end\
end\
\
function UIHandler.public:removeChild( child )\
	local removed = false\
	for i = #self.children, 1, -1 do\
		if self.children[i] == child then\
			table.remove( self.children, i )\
			removed = true\
		end\
	end\
	return removed\
end\
\
function UIHandler.public:unFocus( )\
	if self.focus then\
		self.focus:onUnFocus( )\
		self.focus = false\
	end\
end\
\
function UIHandler.public:setFocus( child )\
	if class.typeOf( child, UIElement ) then\
		if self.focus ~= child then\
			if self.focus then\
				self.focus:onUnFocus( )\
			end\
			child:onFocus( )\
			self.focus = child\
		end\
	else\
		error( \"expected UIElement child\", 3 )\
	end\
end", meta={
  type = "class",
}};["main"]={content="\
require \"buffer\"\
require \"clipboard\"\
require \"display\"\
require \"markup\"\
require \"parser\"\
require \"stencil\"\
\
export \"buffer\"\
export \"clipboard\"\
export \"display\"\
export \"markup\"\
export \"stencil\"\
\
export \"Image\"\
export \"Thread\"\
export \"UIButton\"\
export \"UICanvas\"\
export \"UICode\"\
export \"UIElement\"\
export \"UIFrame\"\
export \"UIHandler\"\
export \"UIImage\"\
export \"UIInput\"\
export \"UIKeyHandler\"\
export \"UIMenu\"\
export \"UIScrollBar\"\
export \"UIText\"\
export \"UITextbox\"", meta={}};["UIScrollBar"]={content="\
\
require \"UIElement\"\
\
UIScrollBar:extends( UIElement )\
\
UIScrollBar.public \"bc\"  \"number\"\
UIScrollBar.public \"tc\"  \"number\"\
\
UIScrollBar.handlesScroll = true\
\
function UIScrollBar:UIScrollBar( x, y, w, h, target, direction )\
	self:UIElement( x, y, w, h )\
\
	self.bc = colours.lightGrey\
	self.tc = colours.grey\
	self.direction = direction or \"vertical\"\
\
	if target then\
		if class.typeOf( target, UIElement ) then\
			if target.isScrollTarget then\
				self.target = target\
			else\
				error( \"cannot set \" .. target:type( ) .. \" as scroll target\", 3 )\
			end\
		else\
			error( \"expected UIElement target\", 3 )\
		end\
	end\
	return self.public\
end\
\
function UIScrollBar.public:setScrollTarget( target )\
	if class.typeOf( target, UIElement ) then\
		if target.isScrollTarget then\
			self.target = target\
		else\
			error( \"cannot set \" .. target:type( ) .. \" as scroll target\", 2 )\
		end\
	else\
		error( \"expected UIElement target\", 2 )\
	end\
end\
\
--[[\
	barsize/traysize = framesize/contentsize\
	barposition = traysize * contentscroll / contentsize\
]]\
\
function UIScrollBar:getBar( )\
	if not self.target then\
		return 0, self.direction == \"vertical\" and self.h or self.w\
	end\
	local traysize\
	if self.direction == \"vertical\" then\
		traysize = self.h\
	else\
		traysize = self.w\
	end\
	local framesize, contentsize, contentscroll\
	if self.direction == \"vertical\" then\
		framesize = self.target:getDisplaySizeV( )\
		contentsize = self.target:getContentSizeV( )\
		contentscroll = self.target:getContentScrollV( )\
	else\
		framesize = self.target:getDisplaySizeH( )\
		contentsize = self.target:getContentSizeH( )\
		contentscroll = self.target:getContentScrollH( )\
	end\
\
	local barsize = math.max( math.floor( traysize * framesize / contentsize ), 1 )\
\
	local barpos = traysize * contentscroll / contentsize\
	return math.ceil( barpos ), barsize\
end\
\
function UIScrollBar.public:draw( x, y )\
	local layer = stencil.addLayer( x, y, self.w, self.h )\
	if self.target then\
		local pos, size = self:getBar( )\
		stencil.rectangle( x, y, self.w, self.h, self.tc, 1, \" \" )\
		if self.direction == \"vertical\" then\
			stencil.rectangle( x, y + pos, self.w, size, self.bc, 1, \" \" )\
		else\
			stencil.rectangle( x + pos, y, size, self.h, self.bc, 1, \" \" )\
		end\
	else\
		stencil.rectangle( x, y, self.w, self.h, self.bc, 1, \" \" )\
	end\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:draw( x + child.x - 1 + self.cx, y + child.y - 1 + self.cy )\
	end\
	stencil.closeLayer( layer )\
end\
\
function UIScrollBar.public:onMouseClick( rx, ry, button )\
	if not self.target then return end\
	local pos, size = self:getBar( )\
	local traysize\
	if self.direction == \"vertical\" then\
		self.downoffset = ry - pos\
		if ry > pos and ry < pos + size - 1 then return end\
		pos = ry - 1\
		traysize = self.h\
	else\
		self.downoffset = rx - pos\
		if rx > pos and rx < pos + size - 1 then return end\
		pos = rx - 1\
		traysize = self.w\
	end\
	pos = math.max( math.min( pos, traysize - size), 0 )\
	if self.direction == \"vertical\" then\
		self.target:setContentScrollV( math.floor( pos / traysize * self.target:getContentSizeV( ) ) )\
	else\
		self.target:setContentScrollH( math.floor( pos / traysize * self.target:getContentSizeH( ) ) )\
	end\
end\
\
function UIScrollBar.public:onMouseDrag( rx, ry, cx, cy, button )\
	if not self.target then return end\
	local pos, size = self:getBar( )\
	local traysize\
	if self.direction == \"vertical\" then\
		pos = ry - self.downoffset\
		traysize = self.h\
	else\
		pos = rx - self.downoffset\
		traysize = self.w\
	end\
	pos = math.max( math.min( pos, traysize - size), 0 )\
	if self.direction == \"vertical\" then\
		self.target:setContentScrollV( math.floor( pos / traysize * self.target:getContentSizeV( ) ) )\
	else\
		self.target:setContentScrollH( math.floor( pos / traysize * self.target:getContentSizeH( ) ) )\
	end\
end\
\
function UIScrollBar.public:onMouseScroll( rx, ry, dir )\
	if not self.target then return end\
	local pos, size = self:getBar( )\
	local traysize\
	if self.direction == \"vertical\" then\
		traysize = self.h\
	else\
		traysize = self.w\
	end\
	pos = math.max( math.min( pos + dir, traysize - size), 0 )\
	if self.direction == \"vertical\" then\
		self.target:setContentScrollV( math.floor( pos / traysize * self.target:getContentSizeV( ) ) )\
	else\
		self.target:setContentScrollH( math.floor( pos / traysize * self.target:getContentSizeH( ) ) )\
	end\
end", meta={
  type = "class",
}};["parser"]={content="\
\
local function split( str, pat )\
	local sopened = false\
	local opened = false\
	local parts = { }\
	local last = 1\
	for i = 1,#str do\
		if str:sub( i, i ) == \"\\\"\" then\
			local count = 0\
			for ii = i - 1, 1, -1 do\
				if str:sub( ii, ii ) ~= \"\\\\\" then\
					break\
				end\
				count = count + 1\
			end\
			if math.floor( count / 2 ) == count / 2 then -- an even number of \\s therefore a string opener\
				if sopened and sopened == str:sub( i, i ) then\
					sopened = false\
				elseif not sopened then\
					sopened = str:sub( i, i )\
				end\
			end\
		elseif not sopened then\
			if str:sub( i, i + #pat - 1 ) == pat then\
				table.insert( parts, str:sub( last, i - 1 ) )\
				last = i + #pat\
			end\
		end\
	end\
	table.insert( parts, str:sub( last ) )\
	return parts\
end\
\
local function findTags( str )\
	local sopened = false\
	local opened = false\
	local tags = { }\
	for i = 1,#str do\
		if str:sub( i, i ) == \"\\\"\" then\
			local count = 0\
			for ii = i - 1, 1, -1 do\
				if str:sub( ii, ii ) ~= \"\\\\\" then\
					break\
				end\
				count = count + 1\
			end\
			if math.floor( count / 2 ) == count / 2 then -- an even number of \\s therefore a string opener\
				if sopened and sopened == str:sub( i, i ) then\
					sopened = false\
				elseif not sopened then\
					sopened = str:sub( i, i )\
				end\
			end\
		elseif not sopened then\
			if str:sub( i, i ) == \"<\" then\
				opened = i\
			elseif str:sub( i, i ) == \">\" then\
				table.insert( tags, { start = opened, finish = i, content = str:sub( opened + 1, i - 1 ) } )\
			end\
		end\
	end\
	return tags\
end\
\
local function readTags( tags )\
	for i = 1,#tags do\
		local c = tags[i].content\
		tags[i].content = nil\
		if c:sub( 1, 1 ) == \"/\" then\
			tags[i].type = \"close\"\
			tags[i].name = c:sub( 2 )\
		else\
			local parts = split( c, \" \" )\
			tags[i].type = \"open\"\
			tags[i].name = parts[1]\
			tags[i].attributes = { }\
			for ii = 2,#parts do\
				local s, f, name, value = parts[ii]:find( \"([%w_]-)[:=](.+)\" )\
				if s then\
					tags[i].attributes[name] = value\
				end\
			end\
		end\
	end\
	return tags\
end\
\
local function loadAttributes( at )\
	local vals = { }\
	for k, v in pairs( at ) do\
		if v:sub( 1, 1 ) == \"\\\"\" and v:sub( #v ) == \"\\\"\" then\
			local str = loadstring( \"return \" .. v, \"string\" )\
			if str then\
				vals[k] = str( )\
			end\
		else\
			if v == \"true\" or v == \"false\" then\
				vals[k] = v == \"true\"\
			elseif tonumber( v ) then\
				vals[k] = tonumber( v )\
			else\
				vals[k] = v\
			end\
		end\
	end\
	return vals\
end\
\
local _tags = {\
	[\"script\"] = {\
		content = true;\
		children = false;\
		whenloaded = function( parent, attributes, content, scripts, ids, errors )\
			local name = attributes.name or \"script\"\
			local f, err = loadstring( content, name )\
			if f then\
				table.insert( scripts, { run = true, script = f } )\
			else\
				table.insert( errors, err )\
			end\
		end;\
	};\
	[\"style\"] = {\
		content = true;\
		children = false;\
		whenloaded = function( parent, attributes, content, scripts, ids )\
			local s = Style( content )\
			s:save( attributes.name or \"default\" )\
		end;\
	};\
}\
\
function registerTag( name, content, children, whenloaded, parents, childrenallowed )\
	_tags[name] = { content = content, children = children, whenloaded = whenloaded, parents = parents, childrenallowed = childrenallowed }\
end\
\
local loadString\
\
local function groupTags( tags, str, parenttype )\
	local t = { }\
	local i = 1\
	while i <= #tags do\
		local name = tags[i].name\
		if _tags[name] then\
			if tags[i].type == \"open\" then\
				if _tags[name].parents then\
					local ok = false\
					for i = 1,#_tags[name].parents do\
						if _tags[name].parents[i] == parenttype then\
							ok = true\
							break\
						end\
					end\
					if not ok then\
						error( \"cannot have \" .. parenttype .. \" as a parent to \" .. name, 0 )\
					end\
				end\
				local tag = {\
					name = name;\
					attributes = loadAttributes( tags[i].attributes );\
					whenloaded = _tags[name].whenloaded;\
				}\
				if _tags[name].content then\
					local layer = 1\
					local found = false\
					for c = i + 1, #tags do\
						if tags[c].name == name then\
							if tags[c].type == \"open\" then\
								layer = layer + 1\
							else\
								layer = layer - 1\
								if layer == 0 then\
									found = c\
									break\
								end\
							end\
						end\
					end\
					if found then\
						tag.content = str:sub( tags[i].finish + 1, tags[found].start - 1 )\
						i = found\
					else\
						error( \"ending tag expected for \" .. name, 0 )\
					end\
				end\
				if tag.content and _tags[name].children then\
					tag.children = loadString( tag.content, tag.name )\
					tag.content = nil\
					if _tags[name].childrenallowed then\
						for i = 1,#tag.children do\
							local ok = false\
							for ii = 1,#_tags[name].childrenallowed do\
								if _tags[name].childrenallowed[ii] == tag.children[i].name then\
									ok = true\
									break\
								end\
							end\
							if not ok then\
								error( \"not allowed \" .. tag.children[i].name .. \" inside a \" .. tag.name, 0 )\
							end\
						end\
					end\
				end\
				table.insert( t, tag )\
				i = i + 1\
			else\
				error( \"expected opening tag before closing tag for \" .. name, 0 )\
			end\
		else\
			error( \"unknown tag: \" .. name, 0 )\
		end\
	end\
	return t\
end\
\
function loadString( str, parent )\
	return groupTags( readTags( findTags( str ) ), str, parent or \"frame\" )\
end\
\
local loadElements\
function loadElements( children, parent, scripts, ids, errors )\
	if not scripts then\
		scripts = { }\
		ids = { }\
		errors = { }\
	end\
	for i = 1,#children do\
		local child = children[i].whenloaded( parent, children[i].attributes, children[i].content, scripts, ids, errors )\
		if children[i].children then\
			loadElements( children[i].children, child, scripts, ids, errors )\
		end\
	end\
	return parent, scripts, ids, errors\
end\
\
function load( str, frame )\
	local tags = loadString( str )\
	return loadElements( tags, frame )\
end", meta={
  type = "lib",
}};["UICode"]={content="\
\
require \"UIElement\"\
\
UICode:extends( UIElement )\
\
UICode.handlesKeys = true\
UICode.handlesScroll = true\
UICode.isScrollTarget = true\
UICode.handlesTab = true\
UICode.scrollDirection = \"vertical\"\
\
UICode.public \"showLines\" \"boolean\"\
UICode.public \"syntax\" \"table\"\
\
UICode.public \"onChange\" \"function\"\
UICode.public \"onCtrlKey\" \"function\"\
\
UICode.public \"selected\"\
UICode.public.selected.write = false\
function UICode.public.selected:read( )\
	return not not self.selection\
end\
\
function UICode:UICode( x, y, w, h, syntax )\
	self:UIElement( x, y, w, h )\
\
	self.showLines = true\
	self.lineWidth = 4\
	self.linechars = { }\
\
	self.selection = false\
\
	self.scrollx = 0\
	self.scrolly = 0\
	self.cursorx = 1\
	self.cursory = 1\
\
	self.lastclick = false\
\
	self.syntax = syntax or {\
		default = { bc = colours.white, tc = colours.black };\
		words = { };\
		blocks = { };\
		linen = { bc = colours.grey, tc = colours.white };\
		string = { tc = colours.lightGrey };\
		symbols = { };\
		selection = { bc = colours.blue, tc = colours.white };\
	}\
\
	self.lines = { \"\" }\
	self.characters = { }\
\
	return self.public\
end\
\
function UICode.public:updateCharacters( )\
	self.linechars = { [1] = 1 }\
	local str = table.concat( self.lines, \"\\n\" )\
	local characters = { }\
	local line = 1\
	local pos = 1\
	local done = true\
	local function nextC( )\
		local char = str:sub( pos, pos )\
		pos = pos + 1\
		done = false\
		return char\
	end\
	local function setC( colour, char, d )\
		if done and not d then return end\
		if char == \"\\n\" then\
			done = true\
			line = line + 1\
			-- self.linechars[line] = pos\
			return\
		end\
		if #char == 0 then return end\
		done = true\
		table.insert( characters, { colour = colour, char = char, line = line } )\
	end\
	while pos <= #str do\
		local c = nextC( )\
		if c == \"\\\"\" then\
			setC( self.syntax.string, c )\
			local escape = false\
			for i = pos, #str do\
				c = nextC( )\
				if escape then\
					setC( self.syntax.string.escape or self.syntax.string, c )\
					escape = false\
				else\
					if c == \"\\\\\" then\
						setC( self.syntax.string.escape or self.syntax.string, c )\
						escape = true\
					elseif c == \"\\\"\" then\
						setC( self.syntax.string, c )\
						break\
					else\
						setC( self.syntax.string, c )\
					end\
				end\
			end\
		elseif c:find \"[abcdefghijklmnoparstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_%.]\" then\
			local word = c\
			c = nextC( )\
			while c:find \"[%w_%.]\" do\
				word = word .. c\
				c = nextC( )\
			end\
			for i = 1, #word do\
				if self.syntax.words[word] then\
					setC( self.syntax.words[word], word:sub( i, i ), true )\
				else\
					setC( self.syntax.default, word:sub( i, i ), true )\
				end\
			end\
			done = false\
		elseif self.syntax.symbols[c] then\
			setC( self.syntax.symbols[c], c )\
		end\
		if not done then\
			for i = 1, #self.syntax.blocks do\
				if c == self.syntax.blocks[i].start:sub( 1, 1 ) then\
					if str:sub( pos, pos + #self.syntax.blocks[i].start - 2 ) == self.syntax.blocks[i].start:sub( 2 ) then\
						local block = self.syntax.blocks[i]\
						setC( block, c )\
						for i = 1, #block.start - 1 do\
							c = nextC( )\
							setC( block, c )\
						end\
						while #c > 0 do\
							if str:sub( pos, pos + #block.finish - 1 ) == block.finish then\
								for i = 1, #block.finish do\
									c = nextC( )\
									setC( block, c )\
								end\
								break\
							end\
							c = nextC( )\
							setC( block, c )\
						end\
						break\
					end\
				end\
			end\
		end\
		setC( self.syntax.default, c )\
	end\
	self.characters = characters\
	if self.showLines then\
		self.lineWidth = math.floor( math.log( #self.lines ) / math.log( 10 ) ) + 4\
	else\
		self.lineWidth = 0\
	end\
end\
\
function UICode.public:update( dt )\
	if self.cursory > #self.lines then\
		self.cursory = #self.lines\
	end\
	if self.cursorx > #( self.lines[self.cursory] or \"\" ) + 1 then\
		self.cursorx = #( self.lines[self.cursory] or \"\" ) + 1\
	end\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:update( dt )\
	end\
end\
\
local tabsize = 4\
\
function UICode.public:draw( x, y )\
	local layer = stencil.addLayer( x, y, self.w, self.h )\
	local characters = self.characters\
	stencil.rectangle( x, y, self.w, self.h, self.syntax.default.bc, self.syntax.default.tc, \" \" )\
	if self.showLines then\
		for i = 1, self.h do\
			if i + self.scrolly <= #self.lines then\
				local n = tostring( i + self.scrolly )\
				stencil.textLine( x, y + i - 1, self.syntax.linen.bc, self.syntax.linen.tc, (\" \"):rep( self.lineWidth - 2 - #n ) .. n .. \" \" )\
			else\
				stencil.textLine( x, y + i - 1, self.syntax.linen.bc, 1, (\" \"):rep( self.lineWidth - 1 ) )\
			end\
		end\
	end\
	local xx, yy, cx = 1, 1, 1\
	local tabthisline = true\
	local i = self.linechars[self.scrolly + 1] or 1\
	while i <= #characters do\
		if characters[i].line > yy then\
			xx = 1\
			cx = 1\
			yy = characters[i].line\
			tabthisline = true\
		end\
\
		local bc, tc = characters[i].colour.bc or self.syntax.default.bc, characters[i].colour.tc or self.syntax.default.tc\
		if self.cursory == characters[i].line then\
			bc = characters[i].colour.lbc or characters[i].colour.bc or self.syntax.default.lbc or self.syntax.default.bc\
			tc = characters[i].colour.ltc or characters[i].colour.tc or self.syntax.default.ltc or self.syntax.default.tc\
		end\
		if self.selection then\
			local ssx, ssy, sex, sey\
			if self.selection.y < self.cursory then\
				ssy = self.selection.y\
				ssx = self.selection.x\
				sey = self.cursory\
				sex = self.cursorx\
			elseif self.selection.y > self.cursory then\
				ssy = self.cursory\
				ssx = self.cursorx\
				sey = self.selection.y\
				sex = self.selection.x\
			else\
				ssy = self.selection.y\
				ssx = math.min( self.selection.x, self.cursorx )\
				sey = self.cursory\
				sex = math.max( self.selection.x, self.cursorx )\
			end\
			if yy == ssy then\
				if yy == sey then\
					if cx >= ssx and cx <= sex then\
						bc = self.syntax.selection.bc\
						tc = self.syntax.selection.tc\
					end\
				else\
					if cx >= ssx then\
						bc = self.syntax.selection.bc\
						tc = self.syntax.selection.tc\
					end\
				end\
			elseif yy == sey then\
				if cx <= sex then\
					bc = self.syntax.selection.bc\
					tc = self.syntax.selection.tc\
				end\
			elseif yy > ssy and yy < sey then\
				bc = self.syntax.selection.bc\
				tc = self.syntax.selection.tc\
			end\
		end\
		local rx = xx - self.scrollx\
		local ry = yy - self.scrolly\
		if rx >= 1 and rx <= self.w - self.lineWidth and ry >= 1 and ry <= self.h then\
			if characters[i].char ~= \"	\" then\
				tabthisline = false\
				stencil.pixel( x + rx - 1 + self.lineWidth, y + ry - 1, bc, tc, characters[i].char )\
			else\
				for i = 1, ( tabsize - ( xx - 1 ) % tabsize ) - 1 do\
					stencil.pixel( x + rx - 2 + self.lineWidth + i, y + ry - 1, bc, tc, \" \" )\
				end\
				if self.syntax.tab and tabthisline then\
					stencil.pixel( x + rx - 2 + self.lineWidth + ( tabsize - ( xx - 1 ) % tabsize ), y + ry - 1, self.syntax.tab.bc or bc, self.syntax.tab.tc or tc, self.syntax.tab.char or \" \" )\
				else\
					stencil.pixel( x + rx - 2 + self.lineWidth + ( tabsize - ( xx - 1 ) % tabsize ), y + ry - 1, bc, tc, \" \" )\
				end\
			end\
		end\
		if characters[i].char == \"	\" then\
			xx = xx + ( tabsize - ( xx - 1 ) % tabsize )\
		else\
			xx = xx + 1\
		end\
		if ry > self.h then\
			break\
		end\
		cx = cx + 1\
		i = i + 1\
	end\
	if self.focussed and not self.selection then\
		local xx, yy = self:getCursorPos( )\
		stencil.setCursorBlink( x + xx - 1 + self.lineWidth, y + yy - 1, self.syntax.default.tc )\
	end\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:draw( x + child.x - 1 + self.cx, y + child.y - 1 + self.cy )\
	end\
	stencil.closeLayer( layer )\
end\
\
function UICode:setCursorPos( x, y )\
	self.cursorx = x\
	self.cursory = y\
	local ry = self.cursory\
	local l = self.lines[self.cursory]\
	local rx = 0\
	for i = 1, self.cursorx - 1 do\
		if l:sub( i, i ) == \"	\" then\
			rx = rx + ( tabsize - rx % tabsize )\
		else\
			rx = rx + 1\
		end\
	end\
	rx = rx + 1\
	if ry <= self.scrolly then\
		self.scrolly = ry - 1\
	elseif ry >= self.scrolly + self.h then\
		self.scrolly = ry - self.h\
	end\
	if rx <= self.scrollx then\
		self.scrollx = rx - 1\
	elseif rx >= self.scrollx + ( self.w - self.lineWidth ) then\
		self.scrollx = rx - ( self.w - self.lineWidth )\
	end\
end\
\
function UICode:getCursorPos( )\
	local y = self.cursory - self.scrolly\
	local l = self.lines[self.cursory] or \"\"\
	local x = 0\
	for i = 1, self.cursorx - 1 do\
		if l:sub( i, i ) == \"	\" then\
			x = x + ( tabsize - x % tabsize )\
		else\
			x = x + 1\
		end\
	end\
	return x + 1 - self.scrollx, y\
end\
\
function UICode:coordsToCursor( x, y )\
	if x <= self.lineWidth then\
		return\
	end\
	x = x + self.scrollx - self.lineWidth\
	if self.lines[y+self.scrolly] then\
		local l = self.lines[y + self.scrolly]\
		local cx = 0\
		for i = 1, #l do\
			if l:sub( i, i ) == \"	\" then\
				cx = cx + ( tabsize - ( cx ) % tabsize )\
			else\
				cx = cx + 1\
			end\
			if cx >= x then\
				return i, y + self.scrolly\
			end\
		end\
		return #l + 1, y + self.scrolly\
	end\
	return #self.lines[#self.lines] + 1, #self.lines\
end\
\
function UICode:getSelectionBounds( )\
	local ssx, ssy, sex, sey\
	if self.selection.y < self.cursory then\
		ssy = self.selection.y\
		ssx = self.selection.x\
		sey = self.cursory\
		sex = self.cursorx\
	elseif self.selection.y > self.cursory then\
		ssy = self.cursory\
		ssx = self.cursorx\
		sey = self.selection.y\
		sex = self.selection.x\
	else\
		ssy = self.selection.y\
		ssx = math.min( self.selection.x, self.cursorx )\
		sey = self.cursory\
		sex = math.max( self.selection.x, self.cursorx )\
	end\
	return ssx, ssy, sex, sey\
end\
\
function UICode:write( str )\
	local cx, cy = self.cursorx, self.cursory\
	for i = 1, #str do\
		if str:sub( i, i ) == \"\\n\" then\
			cy = cy + 1\
			cx = 1\
			table.insert( self.lines, cy, \"\" )\
		else\
			self.lines[cy] = self.lines[cy]:sub( 1, cx - 1 ) .. str:sub( i, i ) .. self.lines[cy]:sub( cx )\
			cx = cx + 1\
		end\
	end\
	self:setCursorPos( cx, cy )\
end\
\
function UICode:setSelection( str )\
	local ssx, ssy, sex, sey = self:getSelectionBounds( )\
	local line_end = self.lines[sey]:sub( sex + 1 )\
	self.lines[ssy] = self.lines[ssy]:sub( 1, ssx - 1 )\
	self:setCursorPos( ssx, ssy )\
	for i = ssy + 1, sey do\
		table.remove( self.lines, ssy + 1 )\
	end\
	self:write( str .. line_end )\
	self:setCursorPos( self.cursorx - #line_end, self.cursory )\
	self.selection = false\
end\
\
function UICode.public:getSelection( str )\
	if self.selection then\
		local ssx, ssy, sex, sey = self:getSelectionBounds( )\
		if ssy == sey then\
			return self.lines[ssy]:sub( ssx, sex )\
		end\
		local selected = self.lines[ssy]:sub( ssx )\
		for i = ssy + 1, sey - 1 do\
			selected = selected .. \"\\n\" .. self.lines[i]\
		end\
		selected = selected .. \"\\n\" .. self.lines[sey]:sub( 1, sex )\
		return selected\
	end\
end\
\
function UICode.public:setSelection( str )\
	if self.selection then\
		self:setSelection( str )\
		self.public:updateCharacters( )\
	end\
end\
\
function UICode.public:write( str )\
	self:write( str )\
	self.public:updateCharacters( )\
end\
\
function UICode.public:onMouseClick( rx, ry, button )\
	if self.selection then\
		self.selection = false\
	end\
	local x, y = self:coordsToCursor( rx, ry )\
	if self.lastclick and self.lastclick.x == rx and self.lastclick.y == ry and os.clock( ) - self.lastclick.time <= 0.3 and button == 1 then\
		local bounds = { min = x, max = x }\
		local line = self.lines[y]\
		local c = line:sub( x, x )\
		if c:find \"%s\" then\
			for i = x - 1, 1, -1 do\
				if not line:sub( i, i ):find \"%s\" then\
					break\
				end\
				bounds.min = i\
			end\
			for i = x + 1, #line do\
				if not line:sub( i, i ):find \"%s\" then\
					break\
				end\
				bounds.max = i\
			end\
		elseif c:find \"[%w_]\" then\
			for i = x - 1, 1, -1 do\
				if not line:sub( i, i ):find \"[%w_]\" then\
					break\
				end\
				bounds.min = i\
			end\
			for i = x + 1, #line do\
				if not line:sub( i, i ):find \"[%w_]\" then\
					break\
				end\
				bounds.max = i\
			end\
		else\
			for i = x - 1, 1, -1 do\
				if line:sub( i, i ):find \"%s\" or line:sub( i, i ):find \"[%w_]\" then\
					break\
				end\
				bounds.min = i\
			end\
			for i = x + 1, #line do\
				if line:sub( i, i ):find \"%s\" or line:sub( i, i ):find \"[%w_]\" then\
					break\
				end\
				bounds.max = i\
			end\
		end\
		self.selection = { x = bounds.min, y = y }\
		self.cursorx = bounds.max\
		self.cursory = y\
		self.lastclick = false\
		return\
	elseif button == 1 then\
		self.lastclick = { x = rx, y = ry, time = os.clock( ) }\
	end\
	if x then\
		self:setCursorPos( x, y )\
	end\
end\
\
function UICode.public:onMouseDrag( rx, ry, cx, cy, button )\
	local x, y = self:coordsToCursor( rx, ry )\
	if x then\
		if not self.selection then\
			self.selection = { x = self.cursorx, y = self.cursory }\
		end\
		self:setCursorPos( x, y )\
	end\
end\
\
function UICode.public:onMouseScroll( rx, ry, dir )\
	if self.scrolly > 0 and dir == -1 then\
		self.scrolly = self.scrolly - 1\
	elseif self.scrolly < #self.lines - self.h and dir == 1 then\
		self.scrolly = self.scrolly + 1\
	end\
end\
\
function UICode.public:onKeyPress( key, lastkey )\
	if not self.focussed then\
		return\
	end\
	if lastkey == 29 then\
		if key == keys.c or key == keys.x or key == keys.b then\
			if key == keys.c then\
				if self.selection then\
					clipboard.set( \"plaintext\", self.public:getSelection( ) )\
				else\
					clipboard.set( \"plaintext\", self.lines[self.cursory] or \"\" )\
				end\
			elseif key == keys.x then\
				if self.selection then\
					clipboard.set( \"plaintext\", self.public:getSelection( ) )\
					self:setSelection \"\"\
					self.selection = false\
				else\
					clipboard.set( \"plaintext\", self.lines[self.cursory] or \"\" )\
					table.remove( self.lines, self.cursory )\
				end\
				self.public:updateCharacters( )\
				if self.onChange then\
					self.onChange( self.public, \"cut\" )\
				end\
			elseif key == keys.b then\
				local mode, data = clipboard.get( )\
				if mode == \"plaintext\" then\
					if self.selection then\
						self:setSelection( data )\
						self.selection = false\
					else\
						self:write( data )\
					end\
					self.public:updateCharacters( )\
				elseif self.onCtrlKey then\
					self.onCtrlKey( self.public, key )\
				end\
				if self.onChange then\
					self.onChange( self.public, \"paste\" )\
				end\
			end\
			return\
		end\
		if self.onCtrlKey then\
			self.onCtrlKey( self.public, key )\
		end\
		return\
	end\
	if key == keys.left then\
		if self.selection then\
			local ssx, ssy, sex, sey = self:getSelectionBounds( )\
			self:setCursorPos( ssx, ssy )\
			self.selection = false\
		else\
			if self.cursorx == 1 then\
				if self.cursory > 1 then\
					self:setCursorPos( #self.lines[self.cursory - 1] + 1, self.cursory - 1 )\
				end\
			else\
				self:setCursorPos( self.cursorx - 1, self.cursory )\
			end\
		end\
	elseif key == keys.right then\
		if self.selection then\
			local ssx, ssy, sex, sey = self:getSelectionBounds( )\
			self:setCursorPos( sex, sey )\
			self.selection = false\
		else\
			if self.cursorx >= #self.lines[self.cursory] + 1 then\
				if self.cursory < #self.lines then\
					self:setCursorPos( 1, self.cursory + 1 )\
				else\
					self.cursorx = #self.lines[self.cursory] + 1\
				end\
			else\
				self:setCursorPos( self.cursorx + 1, self.cursory )\
			end\
		end\
	elseif key == keys.up and self.cursory > 1 then\
		if self.selection then\
			local ssx, ssy, sex, sey = self:getSelectionBounds( )\
			self:setCursorPos( ssx, ssy )\
			self.selection = false\
		else\
			local x, y = self:getCursorPos( )\
			self:setCursorPos( self:coordsToCursor( x + self.lineWidth, y - 1 ) )\
		end\
	elseif key == keys.down and self.cursory < #self.lines then\
		if self.selection then\
			local ssx, ssy, sex, sey = self:getSelectionBounds( )\
			self:setCursorPos( sex, sey )\
			self.selection = false\
		else\
			local x, y = self:getCursorPos( )\
			self:setCursorPos( self:coordsToCursor( x + self.lineWidth, y + 1 ) )\
		end\
	elseif key == keys.enter then\
		if self.selection then\
			self:setSelection \"\\n\"\
		else\
			local whitespace = self.lines[self.cursory]:match \"^(%s*)\"\
			table.insert( self.lines, self.cursory + 1, whitespace .. self.lines[self.cursory]:sub( self.cursorx ) )\
			self.lines[self.cursory] = self.lines[self.cursory]:sub( 1, self.cursorx - 1 )\
			self:setCursorPos( #whitespace + 1, self.cursory + 1 )\
		end\
		self.public:updateCharacters( )\
		if self.onChange then\
			self.onChange( self.public, \"\\n\" )\
		end\
	elseif key == keys.tab then\
		if self.selection then\
			local ssx, ssy, sex, sey = self:getSelectionBounds( )\
			if ssy == sey then\
				self:setSelection \"	\"\
			else\
				for y = ssy, sey do\
					if lastkey == keys.leftShift then\
						self.lines[y] = self.lines[y]:gsub( \"^	\", \"\", 1 )\
					else\
						self.lines[y] = \"	\" .. self.lines[y]\
					end\
				end\
			end\
		else\
			self.lines[self.cursory] = self.lines[self.cursory]:sub( 1, self.cursorx - 1 ) .. \"	\" .. self.lines[self.cursory]:sub( self.cursorx )\
			self:setCursorPos( self.cursorx + 1, self.cursory )\
		end\
		self.public:updateCharacters( )\
		if self.onChange then\
			self.onChange( self.public, \"	\" )\
		end\
	elseif key == keys.delete then\
		if self.selection then\
			self:setSelection \"\"\
		else\
			if self.cursorx == #self.lines[self.cursory] + 1 then\
				if self.lines[self.cursory + 1] then\
					self.lines[self.cursory] = self.lines[self.cursory] .. self.lines[self.cursory + 1]\
					table.remove( self.lines, self.cursory + 1 )\
				end\
			else\
				self.lines[self.cursory] = self.lines[self.cursory]:sub( 1, self.cursorx - 1 ) .. self.lines[self.cursory]:sub( self.cursorx + 1 )\
			end\
		end\
		self.public:updateCharacters( )\
		if self.onChange then\
			self.onChange( self.public, \"delete\" )\
		end\
	elseif key == keys.backspace then\
		if self.selection then\
			self:setSelection \"\"\
		else\
			if self.cursorx == 1 then\
				if self.cursory > 1 then\
					self:setCursorPos( #self.lines[self.cursory - 1] + 1, self.cursory - 1 )\
					self.lines[self.cursory] = self.lines[self.cursory] .. self.lines[self.cursory + 1]\
					table.remove( self.lines, self.cursory + 1 )\
				end\
			else\
				self.lines[self.cursory] = self.lines[self.cursory]:sub( 1, self.cursorx - 2 ) .. self.lines[self.cursory]:sub( self.cursorx )\
				self:setCursorPos( self.cursorx - 1, self.cursory )\
			end\
		end\
		self.public:updateCharacters( )\
		if self.onChange then\
			self.onChange( self.public, \"backspace\" )\
		end\
	elseif key == 199 then -- home\
		local tabs = #( self.lines[self.cursory]:match \"^(	*)\" )\
		self:setCursorPos( tabs + 1, self.cursory )\
	elseif key == 207 then -- end\
		self:setCursorPos( #self.lines[self.cursory] + 1, self.cursory )\
	end\
end\
\
function UICode.public:onTextInput( text )\
	if not self.focussed then\
		return\
	end\
	if self.selection then\
		self:setSelection( text )\
	else\
		self.lines[self.cursory] = self.lines[self.cursory]:sub( 1, self.cursorx - 1 ) .. text .. self.lines[self.cursory]:sub( self.cursorx )\
		self:setCursorPos( self.cursorx + 1, self.cursory )\
	end\
	self.public:updateCharacters( )\
	if self.onChange then\
		self.onChange( self.public, text )\
	end\
end\
\
function UICode.public:setCode( code )\
	self.lines = { }\
	local last = 1\
	for i = 1, #code do\
		if code:sub( i, i ) == \"\\n\" then\
			table.insert( self.lines, code:sub( last, i - 1 ) )\
			last = i + 1\
		end\
	end\
	table.insert( self.lines, code:sub( last ) )\
	self.public:updateCharacters( )\
end\
\
function UICode.public:getCode( )\
	return table.concat( self.lines, \"\\n\" )\
end\
\
function UICode.public:onFocus( )\
	self.focussed = true\
	self.handlesKeys = true\
	if type( self.whenFocussed ) == \"function\" then\
		self.whenFocussed( self.public )\
	end\
end\
\
function UICode.public:onUnFocus( )\
	self.handlesKeys = false\
	self.focussed = false\
	if type( self.whenUnFocussed ) == \"function\" then\
		self.whenUnFocussed( self.public )\
	end\
end\
\
function UICode.public:focusOn( )\
	local handler = self.public:getHandler( )\
	handler:setFocus( self.public )\
end\
\
function UICode.public:getDisplaySizeH( )\
	return self.w - self.lineWidth\
end\
function UICode.public:getDisplaySizeV( )\
	return self.h\
end\
function UICode.public:getContentSizeH( )\
	local max = 1\
	for i = 1, #self.lines do\
		max = math.max( max, #self.lines[i] )\
	end\
	return max\
end\
function UICode.public:getContentSizeV( )\
	return #self.lines\
end\
function UICode.public:getContentScrollH( )\
	return self.scrollx\
end\
function UICode.public:getContentScrollV( )\
	return self.scrolly\
end\
function UICode.public:setContentScrollH( scroll )\
	self.scrollx = scroll\
end\
function UICode.public:setContentScrollV( scroll )\
	self.scrolly = scroll\
end", meta={
  type = "class",
}};["stencil"]={content="\
\
local function linewrap( str, w )\
	for i = 1, w + 1 do\
		if str:sub( i, i ) == \"\\n\" then\
			return str:sub( 1, i - 1 ), str:sub( i + 1 )\
		end\
	end\
	if #str <= w then\
		return str, \"\"\
	end\
	if str:sub( w + 1, w + 1 ):find \"%s\" then\
		return str:sub( 1, w ), str:sub( w + 1 ):gsub( \"^%s+\", \"\" )\
	end\
	for i = w, 1, -1 do\
		if str:sub( i, i ):find \"%s\" then\
			return str:sub( 1, i ), str:sub( i + 1 )\
		end\
	end\
	return str:sub( 1, w ), str:sub( w + 1 )\
end\
\
local function wordwrap( str, w, h )\
	if w < 1 then return { } end\
	local lines = { }\
	local line\
	while #str > 0 do\
		line, str = linewrap( str, w )\
		table.insert( lines, line )\
	end\
	while #lines > h do\
		lines[#lines] = nil\
	end\
	return lines\
end\
\
local function bbox( x1, y1, w1, h1, x2, y2, w2, h2 )\
	local x, y, w, h\
	if x1 + w1 <= x2 or y1 + h1 <= y2 or x2 + w2 <= x1 or y2 + h2 <= y1 then\
		return false\
	end\
	x = math.max( x1, x2 )\
	w = math.min( x1 + w1, x2 + w2 ) - x\
	y = math.max( y1, y2 )\
	h = math.min( y1 + h1, y2 + h2 ) - y\
	return x, y, w, h\
end\
\
local layers = { }\
local w, h = term.getSize( )\
local limit = { x = 1, y = 1, w = w, h = h }\
\
function pixel( x, y, bc, tc, char )\
	if limit and x >= limit.x and x < limit.x + limit.w and y >= limit.y and y < limit.y + limit.h then\
		buffer.setPixel( x, y, bc, tc, char )\
		return true\
	end\
	return false\
end\
\
function textLine( x, y, bc, tc, text )\
	for i = 1, #text do\
		pixel( x + i - 1, y, bc, tc, text:sub( i, i ) )\
	end\
end\
\
function rectangle( x, y, w, h, bc, tc, char )\
	for i = 0, h - 1 do\
		textLine( x, y + i, bc, tc, ( char or \" \" ):rep( w ) )\
	end\
end\
\
function text( x, y, w, h, bc, tc, text, pad )\
	local lines = wordwrap( text, w, h )\
	if pad then\
		pad( lines )\
	end\
	if bc ~= 0 then\
		while #lines < h do\
			table.insert( lines, string.rep( \" \", math.max( w, 0 ) ) )\
		end\
	end\
	for i = 1, #lines do\
		local line = lines[i]:sub( 1, w )\
		if bc ~= 0 then\
			line = line .. string.rep( \" \", math.max( w - #line, 0 ) )\
		end\
		textLine( x, y + i - 1, bc, tc, line )\
	end\
end\
\
function setCursorBlink( x, y, col )\
	if limit and x >= limit.x and x < limit.x + limit.w and y >= limit.y and y < limit.y + limit.h then\
		buffer.setCursorBlink( x, y, col )\
		return true\
	end\
	return false\
end\
\
function addLayer( x, y, w, h )\
	table.insert( layers, { x = x, y = y, w = w, h = h } )\
	if limit then\
		x, y, w, h = bbox( x, y, w, h, limit.x, limit.y, limit.w, limit.h )\
		if x then\
			limit = { x = x, y = y, w = w, h = h }\
		else\
			limit = false\
		end\
	end\
	return #layers\
end\
\
function closeLayer( layer )\
	while layers[layer] do\
		table.remove( layers, layer )\
	end\
	limit = { x = 1, y = 1, w = w, h = h }\
	for i, l in ipairs( layers ) do\
		local x, y, w, h = bbox( limit.x, limit.y, limit.w, limit.h, l.x, l.y, l.w, l.h )\
		if x then\
			limit = { x = x, y = y, w = w, h = h }\
		else\
			limit = false\
			break\
		end\
	end\
end\
\
function layerCount( )\
	return #layers\
end\
\
function getDrawArea( )\
	if limit then\
		return limit.x, limit.y, limit.w, limit.h\
	end\
	return 0, 0, 0, 0\
end", meta={
  type = "lib",
}};["Image"]={content="\
\
local colourLookup = {\
	[\"0\"] = colours.white;\
	[\"1\"] = colours.orange;\
	[\"2\"] = colours.magenta;\
	[\"3\"] = colours.lightBlue;\
	[\"4\"] = colours.yellow;\
	[\"5\"] = colours.lime;\
	[\"6\"] = colours.pink;\
	[\"7\"] = colours.grey;\
	[\"8\"] = colours.lightGrey;\
	[\"9\"] = colours.cyan;\
	[\"A\"] = colours.purple;\
	[\"B\"] = colours.blue;\
	[\"C\"] = colours.brown;\
	[\"D\"] = colours.green;\
	[\"E\"] = colours.red;\
	[\"F\"] = colours.black;\
	[\" \"] = 0;\
}\
\
local colourSave = { }\
for k, v in pairs( colourLookup ) do\
	colourSave[v] = k\
end\
\
function Image:Image( w, h )\
	self.pixels = { }\
\
	for y = 1, h or 1 do\
		self.pixels[y] = { }\
		for x = 1, w or 1 do\
			self.pixels[y][x] = { bc = 0, tc = 0, char = \"\" }\
		end\
	end\
\
	return self.public\
end\
\
function Image.public:getSize( )\
	return #( self.pixels[1] or { } ), #self.pixels\
end\
\
function Image.public:foreach( f )\
	local w, h = #( self.pixels[1] or { } ), #self.pixels\
	local pixels = { }\
	for y = 1, h do\
		pixels[y] = { }\
		for x = 1, w do\
			pixels[y][x] = { }\
			local bc, tc, char = f( x, y, self.public:getPixel( x, y ) )\
			pixels[y][x].bc = bc or self.pixels[y][x].bc\
			pixels[y][x].tc = tc or self.pixels[y][x].tc\
			pixels[y][x].char = char or self.pixels[y][x].char\
		end\
	end\
	for y = 1, h do\
		for x = 1, w do\
			self.pixels[y][x].bc = pixels[y][x].bc\
			self.pixels[y][x].tc = pixels[y][x].tc\
			self.pixels[y][x].char = pixels[y][x].char\
		end\
	end\
end\
\
function Image.public:pixel( x, y, bc, tc, char )\
	if self.pixels[y] and self.pixels[y][x] then\
		--if bc == 0 then bc = pixels[y][x].bc end\
		--if tc == 0 then char = pixels[y][x].char tc = pixels[y][x].tc end\
		self.pixels[y][x] = { bc = bc, tc = tc, char = char }\
		return true\
	end\
	return false\
end\
\
function Image.public:getPixel( x, y )\
	if self.pixels[y] and self.pixels[y][x] then\
		return self.pixels[y][x].bc, self.pixels[y][x].tc, self.pixels[y][x].char\
	end\
	return false\
end\
\
function Image.public:savestr( str )\
	local w, h = #( self.pixels[1] or { } ), #self.pixels\
	local str = \"\"\
	for y = 1, h do\
		for x = 1, w do\
			local bc = colourSave[self.pixels[y][x].bc]\
			local tc = colourSave[self.pixels[y][x].tc]\
			local char = self.pixels[y][x].char\
			if #char == 0 then\
				char = \" \"\
				bc = colourSave[0]\
			end\
			str = str .. bc .. tc .. char\
		end\
		str = str .. \"\\n\"\
	end\
	return str:sub( 1, -2 )\
end\
\
function Image.public:loadstr( str )\
	local lines = { }\
	local last = 1\
	for i = 1, #str do\
		if str:sub( i, i ) == \"\\n\" then\
			table.insert( lines, str:sub( last, i - 1 ) )\
			last = i + 1\
		end\
	end\
	table.insert( lines, str:sub( last ) )\
	local width = #lines[1] / 3\
	local height = #lines\
	self.public:resize( width, height )\
	for i = 1, #lines do\
		local x = 1\
		for pixel in lines[i]:gmatch( \"[0123456789ABCDEF ][0123456789ABCDEF ].\" ) do\
			local bc = pixel:sub( 1, 1 )\
			local tc = pixel:sub( 2, 2 )\
			local ch = pixel:sub( 3, 3 )\
			self.public:pixel( x, i, colourLookup[bc], colourLookup[tc], ch )\
			x = x + 1\
		end\
	end\
	return self.public\
end\
\
function Image.public:resize( w, h, bc, tc, char )\
	while #self.pixels > h do\
		table.remove( self.pixels, #self.pixels )\
	end\
	while #self.pixels < h do\
		local t = { }\
		for i = 1, #( self.pixels[1] or { } ) do\
			t[i] = { bc = bc or 0, tc = tc or 0, char = char or \"\" }\
		end\
		table.insert( self.pixels, t )\
	end\
	if self.pixels[1] then\
		local cw = #self.pixels[1]\
		while cw > w do\
			for y = 1, h do\
				table.remove( self.pixels[y], #self.pixels[y] )\
			end\
			cw = cw - 1\
		end\
		while cw < w do\
			for y = 1, h do\
				table.insert( self.pixels[y], { bc = bc or 0, tc = tc or 0, char = char or \"\" } )\
			end\
			cw = cw + 1\
		end\
	end\
end", meta={
  type = "class",
}};["markup"]={content="\
\
require \"parser\"\
\
local function loadStandardAttributes( class, attributes, scripts, ids, errors, parent )\
	local x = type( attributes.x ) == \"number\" and attributes.x or 1\
	local y = type( attributes.y ) == \"number\" and attributes.y or 1\
	local w = type( attributes.width ) == \"number\" and attributes.width or 19\
	local h = type( attributes.height ) == \"number\" and attributes.height or 1\
	if attributes.width == \"expand\" then\
		w = parent.w - x + 1\
	end\
	if attributes.height == \"expand\" then\
		h = parent.h - y + 1\
	end\
	if attributes.x == \"right\" then\
		x = parent.w - w + 1\
	end\
	if attributes.y == \"bottom\" then\
		y = parent.h - h + 1\
	end\
	local ob = parent:newChild( class( x, y, w, h ) )\
	if attributes.x == \"centre\" then\
		ob:centreX( )\
	end\
	if attributes.y == \"centre\" then\
		ob:centreY( )\
	end\
	if attributes.id then\
		ids[attributes.id] = ob\
	end\
	if attributes.onFocus then\
		local f, err = loadstring( attributes.onFocus, \"onFocus\" )\
		if f then\
			ob.whenFocussed = f\
			table.insert( scripts, { script = f } )\
		else\
			table.insert( errors, err )\
		end\
	end\
	if attributes.onUnFocus then\
		local f, err = loadstring( attributes.onUnFocus, \"onUnFocus\" )\
		if f then\
			ob.whenUnFocussed = f\
			table.insert( scripts, { script = f } )\
		else\
			table.insert( errors, err )\
		end\
	end\
	if type( attributes.align ) == \"string\" then\
		local children = parent:getChildren( )\
		if #children > 1 then\
			ob:alignTo( attributes.align, children[#children-1], tonumber( attributes.spacing ) )\
			ob.w = w\
			ob.h = h\
		end\
	end\
	return ob\
end\
\
local function loadColours( ob, attributes )\
	local bc = type( attributes.bc ) == \"number\" and attributes.bc\
	local tc = type( attributes.tc ) == \"number\" and attributes.tc\
	if colours[attributes.bc] then bc = colours[attributes.bc] end\
	if attributes.bc == \"transparent\" then bc = 0 end\
	if colours[attributes.tc] then tc = colours[attributes.tc] end\
	if attributes.tc == \"transparent\" then tc = 0 end\
	if bc then\
		ob.bc = bc\
	end\
	if tc then\
		ob.tc = tc\
	end\
end\
\
parser.registerTag( \"text\", true, false, function( parent, attributes, content, scripts, ids, errors )\
	if attributes.width == \"auto\" then\
		attributes.width = #content\
	end\
	local ob = loadStandardAttributes( UIText, attributes, scripts, ids, errors, parent )\
	loadColours( ob, attributes )\
	ob.text = content\
	return ob\
end, nil, nil )\
\
parser.registerTag( \"frame\", true, true, function( parent, attributes, content, scripts, ids, errors )\
	local ob = loadStandardAttributes( UIFrame, attributes, scripts, ids, errors, parent )\
	return ob\
end, nil, nil )\
\
parser.registerTag( \"button\", true, false, function( parent, attributes, content, scripts, ids, errors )\
	if attributes.width == \"auto\" then\
		attributes.width = #content\
	end\
	local ob = loadStandardAttributes( UIButton, attributes, scripts, ids, errors, parent )\
	loadColours( ob, attributes )\
	ob.text = content\
	if attributes.onClick then\
		local f, err = loadstring( attributes.onClick, \"onClick\" )\
		if f then\
			ob.onClick = f\
			table.insert( scripts, { script = f } )\
		else\
			table.insert( errors, err )\
		end\
	end\
	return ob\
end, nil, nil )\
\
parser.registerTag( \"input\", false, false, function( parent, attributes, content, scripts, ids, errors )\
	local ob = loadStandardAttributes( UIInput, attributes, scripts, ids, errors, parent )\
	loadColours( ob, attributes )\
	local fbc = type( attributes.fbc ) == \"number\" and attributes.fbc\
	if colours[attributes.fbc] then fbc = colours[attributes.fbc] end\
	if attributes.fbc == \"transparent\" then fbc = 0 end\
	if fbc then\
		ob.fbc = fbc\
	end\
	if attributes.mask then\
		ob.mask = tostring( attributes.mask )\
	end\
	return ob\
end, nil, nil )\
\
parser.registerTag( \"image\", false, false, function( parent, attributes, content, scripts, ids, errors )\
	local ob = loadStandardAttributes( UIImage, attributes, scripts, ids, errors, parent )\
	if attributes.source then\
		local source = tostring( attributes.source )\
		local h = fs.open( source, \"r\" )\
		if h then\
			local content = h.readAll( )\
			h.close( )\
			ob.image = Image( )\
			ob.image:loadstr( content )\
			ob.w, ob.h = ob.image:getSize( )\
		else\
			ob:remove( )\
			ob = UIButton( ob.x, ob.y, ob.w, ob.h, attributes.alt or \"could not load image\" )\
			ob.tc = colours.lightGrey\
		end\
	else\
		ob.image = Image( ob.w, ob.h )\
		ob.image:foreach( function( )\
			return colours.white, 1, \" \"\
		end )\
	end\
	return ob\
end, nil, nil )\
\
function load( str, frame, penv )\
	local body, scripts, ids, errors = parser.load( str, frame or UIFrame( 1, 1, term.getSize( ) ) )\
\
	ids.body = body\
\
	local env = { }\
	env.document = { }\
	local meta = { __index = penv or { } }\
	if penv then meta.__newindex = penv end\
	setmetatable( env, meta )\
\
	function env.document.getElementById( id )\
		return ids[id]\
	end\
	function env.document.addContent( str, id )\
		if not id then id = \"body\" end\
		if ids[id] then\
			local _, errs = load( str, ids[id], penv )\
			for i = 1, #errs do\
				table.insert( errors, errs[i] )\
			end\
			return true\
		else\
			return false, \"no such id\"\
		end\
	end\
\
	for i = 1,#scripts do\
		setfenv( scripts[i].script, env )\
		if scripts[i].run then\
			scripts[i].script( )\
		end\
	end\
\
	return frame, errors, env.document\
end", meta={
  type = "lib",
}};["UIFrame"]={content="\
\
require \"UIElement\"\
\
UIFrame:extends( UIElement )\
\
UIFrame.handlesMouse = false\
UIFrame.handlesScroll = true\
UIFrame.isScrollTarget = true\
UIFrame.scrollDirection = \"vertical\"\
\
UIFrame.scrolls = true\
UIFrame.public \"scrolls\" \"boolean\"\
\
function UIFrame:UIFrame( x, y, w, h, direction )\
	self:UIElement( x, y, w, h )\
	self.scrollDirection = direction or \"vertical\"\
	return self.public\
end\
\
function UIFrame.public:update( dt )\
	local max = self.scrollDirection == \"vertical\" and self.h or self.w\
	if self.scrollDirection == \"vertical\" then\
		for i = 1, #self.children do\
			max = math.max( max, self.children[i].y + self.children[i].h - 1 )\
		end\
	else\
		for i = 1, #self.children do\
			max = math.max( max, self.children[i].x + self.children[i].w - 1 )\
		end\
	end\
	if self.scrollDirection == \"vertical\" then\
		if max - self.h < -self.cy then\
			self.cy = -max + self.h\
		end\
	else\
		if max - self.w < -self.cx then\
			self.cx = -max + self.w\
		end\
	end\
	if max == ( self.scrollDirection == \"vertical\" and self.h or self.w ) or not self.scrolls then\
		self.handlesScroll = false\
	else\
		self.handlesScroll = true\
	end\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:update( dt )\
	end\
end\
\
function UIFrame.public:onMouseScroll( rx, ry, dir )\
	if self.scrollDirection == \"vertical\" then\
		self.cy = self.cy - dir\
		local max = 0\
		for i = 1, #self.children do\
			max = math.max( max, self.children[i].y + self.children[i].h )\
		end\
		max = max - self.h - 1\
		if self.cy < -max then\
			self.cy = -max\
		end\
		if self.cy > 0 then self.cy = 0 end\
	else\
		self.cx = self.cx - dir\
		local max = 0\
		for i = 1, #self.children do\
			max = math.max( max, self.children[i].x + self.children[i].w )\
		end\
		max = max - self.w - 1\
		if self.cx < -max then\
			self.cx = -max\
		end\
		if self.cx > 0 then self.cx = 0 end\
	end\
end\
\
function UIFrame.public:getDisplaySizeH( )\
	return self.w\
end\
function UIFrame.public:getDisplaySizeV( )\
	return self.h\
end\
\
function UIFrame.public:getContentSizeH( )\
	local max = self.w\
	for i = 1, #self.children do\
		max = math.max( max, self.children[i].x + self.children[i].w - 1 )\
	end\
	return max\
end\
function UIFrame.public:getContentSizeV( )\
	local max = self.h\
	for i = 1, #self.children do\
		max = math.max( max, self.children[i].y + self.children[i].h - 1 )\
	end\
	return max\
end\
\
function UIFrame.public:getContentScrollH( )\
	return -self.cx\
end\
function UIFrame.public:getContentScrollV( )\
	return -self.cy\
end\
\
function UIFrame.public:setContentScrollH( scroll )\
	self.cx = -scroll\
end\
function UIFrame.public:setContentScrollV( scroll )\
	self.cy = -scroll\
end", meta={
  type = "class",
}};["clipboard"]={content="\
\
local current = false\
\
function set( mode, data )\
	current = { mode = mode, data = data }\
end\
\
function get( )\
	if current then\
		return current.mode, current.data\
	end\
end", meta={
  type = "lib",
}};["UIText"]={content="\
\
require \"UIElement\"\
\
UIText:extends( UIElement )\
\
UIText.text = \"\"\
UIText.public \"text\"\
\
UIText.public \"bc\" \"number\"\
UIText.public \"tc\" \"number\"\
\
function UIText:UIText( x, y, w, h, text )\
	self:UIElement( x, y, w, h )\
	self.text = text\
	self.bc = colours.white\
	self.tc = colours.grey\
	return self.public\
end\
\
function UIText.public:draw( x, y )\
	local layer = stencil.addLayer( x, y, self.w, self.h )\
	local text = tostring( self.text )\
	if type( self.text ) == \"function\" then\
		text = self.text( self.public )\
	end\
	stencil.text( x, y, self.w, self.h, self.bc, self.tc, text )\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:draw( x + child.x - 1 + self.cx, y + child.y - 1 + self.cy )\
	end\
	stencil.closeLayer( layer )\
end", meta={
  type = "class",
}};["UICanvas"]={content="\
\
local colour = term.isColour( )\
\
require \"UIElement\"\
require \"Image\"\
UICanvas:extends( UIElement )\
\
UICanvas.public \"cx\" \"number\"\
UICanvas.public \"cy\" \"number\"\
UICanvas.public \"cb\" \"boolean\"\
UICanvas.public \"bc\" \"number\"\
UICanvas.public \"tc\" \"number\"\
UICanvas.public \"image\"\
UICanvas.public.image.write = false\
\
UICanvas.handlesKeys = true\
UICanvas.handlesScroll = true\
UICanvas.handlesTab = true\
UICanvas.handlesEnter = true\
\
local function termObject( canvas )\
	local t = { }\
	function t.write( str )\
		if type( str ) ~= \"string\" and type( str ) ~= \"number\" then return error \"expected string\" end\
		str = tostring( str )\
		for x = 1, #str do\
			canvas.image:pixel( canvas.cx, canvas.cy, canvas.bc, canvas.tc, str:sub( x, x ) )\
			canvas.cx = canvas.cx + 1\
		end\
	end\
	function t.clearLine( )\
		canvas.image:foreach( function( x, y, bc, tc, char )\
			if y == canvas.cy then\
				return canvas.bc, canvas.tc, \" \"\
			end\
		end )\
	end\
	function t.clear( )\
		canvas.image:foreach( function( x, y, bc, tc, char )\
			return canvas.bc, canvas.tc, \" \"\
		end )\
	end\
	function t.setCursorPos( x, y )\
		if type( x ) ~= \"number\" or type( y ) ~= \"number\" then\
			return error \"expected number, number\"\
		end\
		canvas.cx = x\
		canvas.cy = y\
	end\
	function t.getCursorPos( )\
		return canvas.cx, canvas.cy\
	end\
	function t.setBackgroundColour( col )\
		if type( col ) ~= \"number\" then\
			return error \"expected number\"\
		end\
		canvas.bc = col\
	end\
	function t.setTextColour( col )\
		if type( col ) ~= \"number\" then\
			return error \"expected number\"\
		end\
		canvas.tc = col\
	end\
	function t.setBackgroundColor( col )\
		if type( col ) ~= \"number\" then\
			return error \"expected number\"\
		end\
		canvas.bc = col\
	end\
	function t.setTextColor( col )\
		if type( col ) ~= \"number\" then\
			return error \"expected number\"\
		end\
		canvas.tc = col\
	end\
	function t.scroll( dir )\
		canvas.image:foreach( function( x, y, bc, tc, char )\
			if canvas.image:getPixel( x, y + dir ) then\
				return canvas.image:getPixel( x, y + dir )\
			else\
				return canvas.bc, canvas.tc, \" \"\
			end\
		end )\
	end\
	function t.setCursorBlink( state )\
		canvas.cb = not not state\
	end\
	function t.isColour( )\
		return colour\
	end\
	function t.isColor( )\
		return colour\
	end\
	function t.getSize( )\
		return canvas.w, canvas.h\
	end\
\
	return t\
end\
\
local function luaEnvironment( canvas )\
	local env = { }\
	env.fs = fs\
	env.term = term\
	env._VERSION = _VERSION\
	env.pairs = pairs\
	env.ipairs = ipairs\
	env.select = select\
	env.unpack = unpack\
	env.setfenv = setfenv\
	env.getfenv = getfenv\
	env.setmetatable = setmetatable\
	env.getmetatable = getmetatable\
	env.next = next\
	env.rawset = rawset\
	env.rawget = rawget\
	env.rawequal = rawequal\
	env.type = type\
	env.tostring = tostring\
	env.tonumber = tonumber\
	env.pcall = pcall\
	env.xpcall = xpcall\
	env.loadstring = loadstring\
	env.assert = assert\
	env.error = error\
	env.sleep = sleep\
	env.__inext = __inext\
	env.math = math\
	env.string = string\
	env.table = table\
	env.coroutine = coroutine\
	env.keys = keys\
	env.colours = colours\
	env.colors = colors\
	env.vector = vector\
	env.bit = bit\
	env.http = http\
	env.write = write\
	env.print = print\
	env.printError = printError\
	env.read = read\
	env.rednet = rednet\
	local tAPIsLoading = { }\
	env.os = setmetatable( {\
		pullEventRaw = function( sFilter )\
			while true do\
				local event = { coroutine.yield( ) }\
				if not sFilter or sFilter == event[1] then\
					return unpack( event )\
				end\
			end\
		end;\
		pullEvent = function( sFilter )\
			while true do\
				local event = { coroutine.yield( ) }\
				if event[1] == \"terminate\" then\
					error( \"Terminated\", 0 )\
				end\
				if not sFilter or sFilter == event[1] then\
					return unpack( event )\
				end\
			end\
		end;\
		run = function( _tEnv, _sPath, ... )\
		    local tArgs = { ... }\
		    local fnFile, err = env.loadfile( _sPath )\
		    if fnFile then\
		        local tEnv = _tEnv\
		        --setmetatable( tEnv, { __index = function(t,k) return _G[k] end } )\
		        setmetatable( tEnv, { __index = env } )\
		        setfenv( fnFile, tEnv )\
		        local ok, err = pcall( function()\
		            fnFile( unpack( tArgs ) )\
		        end )\
		        if not ok then\
		            if err and err ~= \"\" then\
		                printError( err )\
		            end\
		            return false\
		        end\
		        return true\
		    end\
		    if err and err ~= \"\" then\
		        printError( err )\
		    end\
		    return false\
		end;\
		loadAPI = function( _sPath )\
		    local sName = fs.getName( _sPath )\
		    if tAPIsLoading[sName] == true then\
		        printError( \"API \"..sName..\" is already being loaded\" )\
		        return false\
		    end\
		    tAPIsLoading[sName] = true\
		        \
		    local tEnv = {}\
		    setmetatable( tEnv, { __index = env } )\
		    local fnAPI, err = loadfile( _sPath )\
		    if fnAPI then\
		        setfenv( fnAPI, tEnv )\
		        fnAPI()\
		    else\
		        printError( err )\
		        tAPIsLoading[sName] = nil\
		        return false\
		    end\
		    \
		    local tAPI = {}\
		    for k,v in pairs( tEnv ) do\
		        tAPI[k] =  v\
		    end\
		    \
		    env[sName] = tAPI    \
		    tAPIsLoading[sName] = nil\
		    return true\
		end;\
		unloadAPI = function( _sName )\
		    if _sName ~= \"_G\" and type(env[_sName]) == \"table\" then\
		        env[_sName] = nil\
		    end\
		end;\
	}, { __index = os } );\
	env.help = help\
	env.io = io\
	env.parallel = parallel\
\
	env.loadfile = function( _sFile )\
	    local file = env.fs.open( _sFile, \"r\" )\
	    if file then\
	        local func, err = loadstring( file.readAll(), env.fs.getName( _sFile ) )\
	        file.close()\
	        return func, err\
	    end\
	    return nil, \"File not found\"\
	end\
\
	env.dofile = function( _sFile )\
	    local fnFile, e = env.loadfile( _sFile )\
	    if fnFile then\
	        setfenv( fnFile, env )\
	        return fnFile()\
	    else\
	        error( e, 2 )\
	    end\
	end\
\
	env.shell = shell\
	env.multishell = multishell\
	env.redstone = redstone -- change in future, use device system\
	env.rs = rs -- change in future, use device system\
	env.gps = gps -- change in future, use Nova gps system\
	env.peripheral = peripheral -- change in future, use device system\
	env.disk = disk -- change in future, use filesystem\
	env.window = window -- oh crap...\
	env.textutils = textutils\
	env.paintutils = paintutils\
	env.term = term\
\
	return env\
end\
\
function UICanvas:UICanvas( x, y, w, h )\
	self:UIElement( x, y, w, h )\
	self.image = Image( w, h )\
	self.image:foreach( function( x, y, bc, tc, char )\
		return colours.black, colours.white, \" \"\
	end )\
	self.term = termObject( self.public )\
	self.running = false\
	self.co = false\
	self.cx = 1\
	self.cy = 1\
	self.bc = colours.black\
	self.tc = colours.white\
	self.cb = false\
	self.environment = luaEnvironment( )\
	self.thread = Thread( function( )\
		while true do\
			local event = { coroutine.yield( ) }\
			if event[1] ~= \"mouse_click\"\
			and event[1] ~= \"mouse_drag\"\
			and event[1] ~= \"mouse_scroll\"\
			and event[1] ~= \"key\"\
			and event[1] ~= \"char\"\
			and event[1] ~= \"update\" then\
				self.public:passEvent( unpack( event ) )\
			end\
		end\
	end, true )\
	return self.public\
end\
\
function UICanvas.public:setTask( func )\
	setfenv( func, self.environment )\
	self.co = coroutine.create( func )\
	self.running = true\
end\
\
function UICanvas.public:passEvent( ... )\
	if not self.running then return end\
	local prev = term.redirect( self.term )\
	local ok, err = coroutine.resume( self.co, ... )\
	term.redirect( prev )\
	if not ok then\
		self.running = false\
		local prev = term.redirect( self.term )\
		self.environment.printError( err )\
		term.redirect( prev )\
	end\
	if coroutine.status( self.co ) == \"dead\" then\
		self.running = false\
	end\
end\
\
function UICanvas.public:draw( x, y )\
	local layer = stencil.addLayer( x, y, self.w, self.h )\
	self.image:resize( self.w, self.h )\
	self.image:foreach( function( px, py, bc, tc, char )\
		stencil.pixel( x + px - 1, y + py - 1, bc, tc, char )\
		return bc, tc, char\
	end )\
	if self.cb then\
		stencil.setCursorBlink( x + self.cx - 1, y + self.cy - 1, self.tc )\
	end\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:draw( x + child.x - 1 + self.cx, y + child.y - 1 + self.cy )\
	end\
	stencil.closeLayer( layer )\
end\
\
function UICanvas.public:onMouseClick( x, y, button )\
	self.public:passEvent( \"mouse_click\", button, x, y )\
end\
\
function UICanvas.public:onMouseDrag( x, y, cx, cy, button )\
	self.public:passEvent( \"mouse_drag\", button, x, y )\
end\
\
function UICanvas.public:onMouseScroll( x, y, dir )\
	self.public:passEvent( \"mouse_scroll\", dir, x, y )\
end\
\
function UICanvas.public:onKeyPress( key, lastkey )\
	self.public:passEvent( \"key\", key )\
end\
\
function UICanvas.public:onTextInput( text, lastkey )\
	self.public:passEvent( \"char\", text )\
end", meta={
  type = "class",
}};["UIInput"]={content="\
\
require \"UIElement\"\
\
UIInput:extends( UIElement )\
\
UIInput.handlesKeys = true\
UIInput.handlesScroll = true\
UIInput.tabIndex =  true\
\
UIInput.bc = colours.grey\
UIInput.fbc = colours.lightGrey\
UIInput.tc = colours.black\
UIInput.hbc = colours.blue\
UIInput.htc = colours.white\
\
UIInput.public \"bc\" \"number\"\
UIInput.public \"fbc\" \"number\"\
UIInput.public \"tc\" \"number\"\
UIInput.public \"hbc\" \"number\"\
UIInput.public \"htc\" \"number\"\
\
UIInput.onEnter = false\
UIInput.public \"onEnter\" \"function\"\
UIInput.public \"onCtrlKey\" \"function\"\
\
UIInput.public \"text\" \"string\"\
UIInput.public \"mask\" \"string\"\
\
UIInput.public \"mask\"\
function UIInput.public.mask:write( value )\
	if not value or type( value ) == \"string\" then\
		self.mask = value\
	else\
		error( \"expected string mask\", 3 )\
	end\
end\
\
function UIInput:UIInput( x, y, w, h, mask )\
	self:UIElement( x, y, w, h )\
	self.mask = mask\
	self.cursor = 1\
	self.scroll = 0\
	self.text = \"\"\
	self.focussed = false\
	self.selection = false\
	return self.public\
end\
\
function UIInput.public:draw( x, y )\
	local layer = stencil.addLayer( x, y, self.w, self.h )\
	local bc = self.bc\
	if self.focussed then\
		bc = self.fbc\
	end\
	local text = self.text\
	if self.mask then\
		text = text:gsub( \".\", self.mask:sub( 1, 1 ) )\
	end\
	if self.selection then\
		text = text .. string.rep( \" \", math.max( self.w - #text, 0 ) )\
		for i = 1, #text do\
			local bc = self.bc\
			local tc = self.tc\
			if i >= math.min( self.selection, self.cursor ) and i <= math.max( self.selection, self.cursor ) then\
				bc = self.hbc\
				tc = self.htc\
			elseif self.focussed then\
				bc = self.fbc\
			end\
			stencil.pixel( x + i - self.scroll - 1, y, bc, tc, text:sub( i, i ) )\
		end\
	else\
		text = text:sub( self.scroll + 1 )\
		text = text:sub( 1, self.w )\
		text = text .. string.rep( \" \", self.w - #text )\
		stencil.textLine( x, y, bc, self.tc, text )\
		if self.focussed then\
			stencil.setCursorBlink( x + self.cursor - 1 - self.scroll, y )\
		end\
	end\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:draw( x + child.x - 1 + self.cx, y + child.y - 1 + self.cy )\
	end\
	stencil.closeLayer( layer )\
end\
\
function UIInput:setCursorPos( n )\
	self.cursor = math.max( math.min( n, #self.text + 1 ), 1 )\
	if self.cursor > self.scroll + self.w then\
		self.scroll = self.cursor - self.w\
	end\
	if self.cursor - 1 <= self.scroll then\
		self.scroll = math.max( self.cursor - 1, 1 ) - 1\
	end\
end\
\
function UIInput:write( str )\
	self.text = self.text:sub( 1, self.cursor - 1 ) .. str:gsub( \"\\n\", \" \" ) .. self.text:sub( self.cursor )\
	self:setCursorPos( self.cursor + #str )\
end\
\
function UIInput:setSelection( text )\
	self.text = self.text:sub( 1, math.min( self.selection, self.cursor ) - 1 ) .. self.text:sub( math.max( self.selection, self.cursor ) + 1 )\
	self.cursor = math.min( self.selection, self.cursor )\
	self:write( text )\
end\
\
function UIInput:getSelection( )\
	return self.text:sub( math.min( self.selection, self.cursor ), math.max( self.selection, self.cursor ) )\
end\
\
function UIInput.public:select( min, max )\
	self.selection = min\
	self.cursor = max\
end\
\
function UIInput.public:onMouseClick( rx, ry, button )\
	self.selection = false\
	self:setCursorPos( rx + self.scroll )\
end\
\
function UIInput.public:onMouseDrag( rx, ry )\
	if not self.selection then\
		self.selection = self.cursor\
	end\
	self:setCursorPos( rx + self.scroll )\
end\
\
function UIInput.public:onMouseScroll( rx, ry, dir )\
	self.scroll = math.max( math.min( self.scroll + dir, #self.text - self.w + 1 ), 0 )\
end\
\
function UIInput.public:onKeyPress( key, lastkey )\
	if not self.focussed then\
		return\
	end\
	if lastkey == 29 then\
		if ( ( key == keys.c or key == keys.x ) and not self.mask ) or key == keys.b then\
			if key == keys.c then\
				if self.selection then\
					clipboard.set( \"plaintext\", self:getSelection( ) )\
				else\
					clipboard.set( \"plaintext\", self.text )\
				end\
			elseif key == keys.x then\
				if self.selection then\
					clipboard.set( \"plaintext\", self:getSelection( ) )\
					self:setSelection \"\"\
					self.selection = false\
				else\
					clipboard.set( \"plaintext\", self.text )\
					self.text = \"\"\
				end\
			elseif key == keys.b then\
				local mode, data = clipboard.get( )\
				if mode == \"plaintext\" then\
					if self.selection then\
						self:setSelection( data )\
						self.selection = false\
					else\
						self:write( data )\
					end\
				elseif self.onCtrlKey then\
					self.onCtrlKey( self.public, key )\
				end\
			end\
			return\
		end\
		if self.onCtrlKey then\
			self.onCtrlKey( self.public, key )\
		end\
		return\
	end\
	if key == keys.enter then\
		if type( self.onEnter ) == \"function\" then\
			self.onEnter( self.public )\
		end\
		local handler = self.public:getHandler( )\
		if handler.focus == self.public then\
			handler:unFocus( )\
		end\
	elseif key == keys.left and self.cursor > 1 then\
		if self.selection then\
			self:setCursorPos( math.min( self.selection, self.cursor ) )\
			self.selection = false\
		else\
			self:setCursorPos( self.cursor - 1 )\
		end\
	elseif key == keys.right then\
		if self.selection then\
			self:setCursorPos( math.max( self.selection, self.cursor ) )\
			self.selection = false\
		else\
			self:setCursorPos( self.cursor + 1 )\
		end\
	elseif key == keys.backspace and self.cursor > 1 then\
		if self.selection then\
			self:setSelection \"\"\
			self.selection = false\
		else\
			self.text = self.text:sub( 1, self.cursor - 2 ) .. self.text:sub( self.cursor )\
			self:setCursorPos( self.cursor - 1 )\
		end\
	elseif key == keys.delete then\
		if self.selection then\
			self:setSelection \"\"\
			self.selection = false\
		else\
			self.text = self.text:sub( 1, self.cursor - 1 ) .. self.text:sub( self.cursor + 1 )\
		end\
	end\
end\
\
function UIInput.public:onTextInput( text, lastkey )\
	if not self.focussed then\
		return\
	end\
	if self.selection then\
		self:setSelection( text )\
		self.selection = false\
	else\
		self.text = self.text:sub( 1, self.cursor - 1 ) .. text .. self.text:sub( self.cursor )\
		self:setCursorPos( self.cursor + 1 )\
	end\
end\
\
function UIInput.public:onFocus( )\
	self.focussed = true\
	self.handlesKeys = true\
	if type( self.whenFocussed ) == \"function\" then\
		self.whenFocussed( self.public )\
	end\
end\
\
function UIInput.public:onUnFocus( )\
	self.focussed = false\
	self.handlesKeys = false\
	if type( self.whenUnFocussed ) == \"function\" then\
		self.whenUnFocussed( self.public )\
	end\
end\
\
function UIInput.public:focusOn( )\
	local handler = self.public:getHandler( )\
	handler:setFocus( self.public )\
end", meta={
  type = "class",
}};["buffer"]={content="\
\
local screen = { }\
local last = { }\
local w, h = term.getSize( )\
local bgc = colours.white\
local cb\
\
for y = 1, h do\
	screen[y] = { }\
	last[y] = { }\
	for x = 1, w do\
		screen[y][x] = { bc = 1, tc = 32768, char = \" \" }\
		last[y][x] = { }\
	end\
end\
\
function setPixel( x, y, bc, tc, char )\
	if screen[y] and screen[y][x] then\
		if bc ~= 0 then\
			screen[y][x].bc = bc\
		end\
		if tc == 0 then\
			char = \"\"\
		else\
			screen[y][x].tc = tc\
		end\
		if char ~= \"\" then\
			screen[y][x].char = char\
		end\
		return true\
	end\
	return false\
end\
\
function getPixel( x, y )\
	if last[y] and last[y][x] then\
		return last[y][x].bc, last[y][x].tc, last[y][x].char\
	end\
	return false\
end\
\
function hasChanged( x, y )\
	if screen[y] and screen[y][x] then\
		return screen[y][x].bc ~= last[y][x].bc or screen[y][x].tc ~= last[y][x].tc or screen[y][x].char ~= last[y][x].char\
	end\
	return false\
end\
\
function setCursorBlink( x, y, col )\
	cb = { x = x, y = y, col = col }\
end\
\
function drawChanges( )\
	local lasts = last\
	for y = 1, h do\
		local last\
		for x = 1, w do\
			if hasChanged( x, y ) then\
				if last then\
					if last.bc == screen[y][x].bc and ( last.tc == screen[y][x].tc or screen[y][x].char == \" \" ) then\
						last.char = last.char .. screen[y][x].char\
					else\
						term.setCursorPos( last.x, last.y )\
						term.setBackgroundColour( last.bc )\
						term.setTextColour( last.tc )\
						term.write( last.char )\
						last = { x = x, y = y, bc = screen[y][x].bc, tc = screen[y][x].tc, char = screen[y][x].char }\
					end\
				else\
					last = { x = x, y = y, bc = screen[y][x].bc, tc = screen[y][x].tc, char = screen[y][x].char }\
				end\
				lasts[y][x] = { bc = screen[y][x].bc, tc = screen[y][x].tc, char = screen[y][x].char }\
			elseif last then\
				term.setCursorPos( last.x, last.y )\
				term.setBackgroundColour( last.bc )\
				term.setTextColour( last.tc )\
				term.write( last.char )\
				last = nil\
			end\
		end\
		if last then\
			term.setCursorPos( last.x, last.y )\
			term.setBackgroundColour( last.bc )\
			term.setTextColour( last.tc )\
			term.write( last.char )\
		end\
	end\
	if cb then\
		if cb.col then\
			term.setTextColour( cb.col )\
		end\
		term.setCursorPos( cb.x, cb.y )\
		term.setCursorBlink( true )\
	else\
		term.setCursorBlink( false )\
	end\
end\
\
function clear( )\
	for x = 1, w do\
		for y = 1, h do\
			screen[y][x].bc = bgc\
			screen[y][x].char = \" \"\
		end\
	end\
	cb = false\
end\
\
function setBackgroundColour( col )\
	bgc = col\
end\
\
function reset( )\
	for y = 1, h do\
		last[y] = { }\
		for x = 1, w do\
			last[y][x] = { }\
		end\
	end\
end", meta={
  type = "lib",
}};["UIKeyHandler"]={content="\
\
require \"UIElement\"\
UIKeyHandler:extends( UIElement )\
\
UIKeyHandler.handlesMouse = false\
UIKeyHandler.handlesKeys = true\
\
UIKeyHandler.onKey = false\
UIKeyHandler.public \"onKey\" \"function\"\
UIKeyHandler.onChar = false\
UIKeyHandler.public \"onChar\" \"function\"\
\
function UIKeyHandler:UIKeyHandler( )\
	self:UIElement( 0, 0, 0, 0 )\
	return self.public\
end\
\
function UIKeyHandler.public:onKeyPress( key, lastkey )\
	if self.onKey then\
		self.onKey( self.public, key, lastkey )\
	end\
end\
function UIKeyHandler.public:onTextInput( char, lastkey )\
	if self.onChar then\
		self.onChar( self.public, char, lastkey )\
	end\
end", meta={
  type = "class",
}};["UITextbox"]={content="\
\
local function linewrap( str, w )\
	for i = 1, w + 1 do\
		if str:sub( i, i ) == \"\\n\" then\
			return str:sub( 1, i - 1 ), str:sub( i + 1 )\
		end\
	end\
	if #str <= w then\
		return str, \"\"\
	end\
	if str:sub( w + 1, w + 1 ):find \"%s\" then\
		return str:sub( 1, w ), str:sub( w + 1 ):gsub( \"^%s+\", \"\" )\
	end\
	for i = w, 1, -1 do\
		if str:sub( i, i ):find \"%s\" then\
			return str:sub( 1, i ), str:sub( i + 1 )\
		end\
	end\
	return str:sub( 1, w ), str:sub( w + 1 )\
end\
\
local function wordwrap( str, w, h )\
	local lines = { }\
	local line\
	while #str > 0 do\
		line, str = linewrap( str, w )\
		table.insert( lines, line )\
	end\
	if h then\
		while #lines > h do\
			lines[#lines] = nil\
		end\
	end\
	return lines\
end\
\
require \"UIElement\"\
UITextbox:extends( UIElement )\
\
UITextbox.handlesKeys = true\
UITextbox.tabIndex =  true\
\
UITextbox.public \"text\"\
\
UITextbox.public \"onChange\" \"function\"\
function UITextbox.public.text:write( value )\
	local t = tostring( value )\
	t = t:sub( 1, self.w * self.h )\
	while true do\
		local lines = wordwrap( t, self.w )\
		if #lines <= self.h then\
			break\
		end\
		t = t:sub( 1, -2 )\
	end\
	self.text = t\
end\
\
UITextbox.bc = colours.lightGrey\
UITextbox.fbc = colours.white\
UITextbox.tc = colours.black\
\
UITextbox.public \"bc\" \"number\"\
UITextbox.public \"fbc\" \"number\"\
UITextbox.public \"tc\" \"number\"\
\
UITextbox.onEnter = false\
UITextbox.public \"onEnter\" \"function\"\
\
function UITextbox:UITextbox( x, y, w, h, text, session )\
	self:UIElement( x, y, w, h )\
\
	self.public.text = text\
	self.cursor = cursor\
\
	return self.public\
end\
\
function UITextbox:getCursorXY( )\
	local lines = wordwrap( self.text, self.w, self.h )\
	local c = self.cursor\
	for i = 1, #lines do\
		if #lines[i] <= c then\
			c = c - #lines[i]\
		else\
			return c, i\
		end\
	end\
	if #lines == 0 then\
		return 1, 1\
	elseif self.text:sub( -1, -1 ) == \"\\n\" then\
		return 1, #lines + 1\
	else\
		return #lines[#lines] + 1, #lines\
	end\
end\
\
function UITextbox:getCursorPos( x, y )\
	local lines = wordwrap( self.text, self.w, self.h )\
	if lines[y] then\
		local pos = 0\
		for i = 1, y - 1 do\
			pos = pos + #lines[i]\
		end\
		if #lines[y] >= x then\
			pos = pos + x\
		else\
			pos = pos + #lines[y] + 1\
		end\
		return pos\
	else\
		return #self.text + 1\
	end\
end\
\
function UITextbox.public:draw( x, y )\
	local layer = stencil.addLayer( x, y, self.w, self.h )\
	local text = tostring( self.text )\
	local bc = self.bc\
	if self.focussed then\
		bc = self.fbc\
	end\
	stencil.text( x, y, self.w, self.h, bc, self.tc, self.text )\
	if self.focussed then\
		local cx, cy = self:getCursorXY( )\
		stencil.setCursorBlink( x + cx - 1, y + cy - 1 )\
	end\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:draw( x + child.x - 1 + self.cx, y + child.y - 1 + self.cy )\
	end\
	stencil.closeLayer( layer )\
end\
\
function UITextbox.public:onMouseClick( rx, ry, button )\
	local pos = self:getCursorPos( rx, ry )\
	self.cursor = pos\
end\
\
function UITextbox.public:onKeyPress( key, lastkey )\
	if not self.focussed then\
		return\
	end\
	if key == keys.enter then\
		local c = self.cursor\
		local t = self.text\
		self.text = self.text:sub( 1, self.cursor - 1 ) .. \"\\n\" .. self.text:sub( self.cursor )\
		self.cursor = self.cursor + 1\
		if type( self.onChange ) == \"function\" then\
			self.onChange( self.public )\
		end\
		local lines = wordwrap( self.text, self.w )\
		if #lines > self.h then\
			self.text = t\
			self.cursor = c\
		end\
	elseif key == keys.left and self.cursor > 1 then\
		self.cursor = self.cursor - 1\
	elseif key == keys.right and self.cursor <= #self.text then\
		self.cursor = self.cursor + 1\
	elseif key == keys.backspace and self.cursor > 1 then\
		self.text = self.text:sub( 1, self.cursor - 2 ) .. self.text:sub( self.cursor )\
		self.cursor = self.cursor - 1\
	elseif key == keys.delete then\
		self.text = self.text:sub( 1, self.cursor - 1 ) .. self.text:sub( self.cursor + 1 )\
	end\
end\
\
function UITextbox.public:onTextInput( text, lastkey )\
	if not self.focussed then\
		return\
	end\
	if lastkey ~= keys.leftCtrl then\
		local c = self.cursor\
		local t = self.text\
		self.text = self.text:sub( 1, self.cursor - 1 ) .. text .. self.text:sub( self.cursor )\
		self.cursor = self.cursor + 1\
		if type( self.onChange ) == \"function\" then\
			self.onChange( self.public )\
		end\
		local lines = wordwrap( self.text, self.w )\
		if #lines > self.h then\
			self.text = t\
			self.cursor = c\
		end\
	end\
end\
\
function UITextbox.public:onFocus( )\
	self.focussed = true\
	self.handlesKeys = true\
	if type( self.whenFocussed ) == \"function\" then\
		self.whenFocussed( self.public )\
	end\
end\
\
function UITextbox.public:onUnFocus( )\
	self.focussed = false\
	self.handlesKeys = false\
	if type( self.whenUnFocussed ) == \"function\" then\
		self.whenUnFocussed( self.public )\
	end\
end\
\
function UITextbox.public:focusOn( )\
	local handler = self.public:getHandler( )\
	handler:setFocus( self.public )\
end", meta={
  type = "class",
}};["UIMenu"]={content="\
\
require \"UIElement\"\
\
UIMenu:extends( UIElement )\
\
UIMenu.handlesMouse = false\
UIMenu.handlesScroll = true\
UIMenu.isScrollTarget = true\
UIMenu.scrollDirection = \"vertical\"\
UIMenu.public \"padding\" \"number\"\
\
function UIMenu:UIMenu( x, y, w, h, direction )\
	self:UIElement( x, y, w, h )\
	self.scrollDirection = direction or \"vertical\"\
	self.padding = 0\
	return self.public\
end\
\
function UIMenu.public:update( dt )\
	local max = self.scrollDirection == \"vertical\" and self.h or self.w\
	if self.scrollDirection == \"vertical\" then\
		for i = 1, #self.children do\
			max = math.max( max, self.children[i].y + self.children[i].h - 1 )\
		end\
	else\
		for i = 1, #self.children do\
			max = math.max( max, self.children[i].x + self.children[i].w - 1 )\
		end\
	end\
	if self.scrollDirection == \"vertical\" then\
		if max - self.h < -self.cy then\
			self.cy = -max + self.h\
		end\
	else\
		if max - self.w < -self.cx then\
			self.cx = -max + self.w\
		end\
	end\
	if max == ( self.scrollDirection == \"vertical\" and self.h or self.w ) then\
		self.handlesScroll = false\
	else\
		self.handlesScroll = true\
	end\
	local c = { }\
	for i, child in ipairs( self.children ) do\
		c[i] = child\
	end\
	for i, child in ipairs( c ) do\
		child:update( dt )\
	end\
	local x, y = 1, 1\
	for i, child in ipairs( self.children ) do\
		child.x = x\
		child.y = y\
		if self.scrollDirection == \"vertical\" then\
			child.w = self.w\
			y = y + child.h + self.padding\
		else\
			child.h = self.h\
			x = x + child.w + self.padding\
		end\
	end\
end\
\
function UIMenu.public:onMouseScroll( rx, ry, dir )\
	if self.scrollDirection == \"vertical\" then\
		self.cy = self.cy - dir\
		local max = 0\
		for i = 1, #self.children do\
			max = math.max( max, self.children[i].y + self.children[i].h )\
		end\
		max = max - self.h - 1\
		if self.cy < -max then\
			self.cy = -max\
		end\
		if self.cy > 0 then self.cy = 0 end\
	else\
		self.cx = self.cx - dir\
		local max = 0\
		for i = 1, #self.children do\
			max = math.max( max, self.children[i].x + self.children[i].w )\
		end\
		max = max - self.w - 1\
		if self.cx < -max then\
			self.cx = -max\
		end\
		if self.cx > 0 then self.cx = 0 end\
	end\
end\
\
function UIMenu.public:getDisplaySizeH( )\
	return self.w\
end\
function UIMenu.public:getDisplaySizeV( )\
	return self.h\
end\
\
function UIMenu.public:getContentSizeH( )\
	local max = self.w\
	for i = 1, #self.children do\
		max = math.max( max, self.children[i].x + self.children[i].w - 1 )\
	end\
	return max\
end\
function UIMenu.public:getContentSizeV( )\
	local max = self.h\
	for i = 1, #self.children do\
		max = math.max( max, self.children[i].y + self.children[i].h - 1 )\
	end\
	return max\
end\
\
function UIMenu.public:getContentScrollH( )\
	return -self.cx\
end\
function UIMenu.public:getContentScrollV( )\
	return -self.cy\
end\
\
function UIMenu.public:setContentScrollH( scroll )\
	self.cx = -scroll\
end\
function UIMenu.public:setContentScrollV( scroll )\
	self.cy = -scroll\
end", meta={
  type = "class",
}};}
--/end of files
local autorun = {"Thread";"UIButton";"UIImage";"UIElement";"UIHandler";"UIScrollBar";"UICode";"Image";"UIFrame";"UIText";"UICanvas";"UIInput";"UIKeyHandler";"UITextbox";"UIMenu";"main"}
--[[type="lib"]]

-- Swift Class Library
-- Made by awsumben13
-- Feel free to use this in any of your projects but keep this at the top and give credit where necessary

--[[
	This class library offers:
		Inheritance "Class:extends( other class )"
		Initialiser methods "function ClassName:ClassName( )"
		Public / private variables with customisable read/write access "Class.public.x.write = false"
		Static variables ( accessed from the class object ) "Class.static.x = 5"
		Custom metamethods including __index and __newindex "Class.meta.index = { }"
]]

local class = { }

function class.new( name )

	local object = { }
	local public = { }

	object.public = { }
	object.private = { }
	object.static = { }
	object.name = name
	object.extends = false
	object.class = public

	public.name = name

	local customindex = false
	local customnewindex = false
	local objectmeta = { }

	function public:new( ... )

		local ob = { }
		local pb = { }

		ob.class = public
		ob.public = pb

		setmetatable( ob, {
			__index = object.private;
		} )

		function pb:type( full )
			return ob.class:type( full )
		end

		function pb:typeOf( class )
			return ob.class:typeOf( class )
		end

		local obmeta = { }
		obmeta.__index = function( _, k )
			if object.public[k] then
				if object.public[k].read then
					local val
					if customindex then
						if type( customindex ) == "function" then
							return customindex( ob, k )
						else
							return customindex[k]
						end
					elseif type( object.public[k].read ) == "function" then
						val = object.public[k].read( ob )
					elseif object.public[k].value ~= nil then
						val = object.public[k].value
					else
						val = ob[k]
					end
					if type( val ) == "function" then
						return function( self, ... )
							if self == pb then
								return val( ob, ... )
							end
							return val( self, ... )
						end
					end
					return val
				else
					error( "variable has no read access", 2 )
				end
			elseif customindex then
				if type( customindex ) == "function" then
					return customindex( ob, k )
				else
					return customindex[k]
				end
			else
				error( "no such variable \"" .. tostring( k ) .. "\"", 2 )
			end
		end;
		obmeta.__newindex = function( _, k, v )
			if object.public[k] then
				if object.public[k].write then
					if customnewindex then
						if type( customnewindex ) == "function" then
							return customnewindex( ob, k, v )
						else
							customnewindex[k] = v
						end
					elseif type( object.public[k].write ) == "function" then
						object.public[k].write( ob, v )
					else
						ob[k] = v
					end
				else
					error( "variable has no write access", 2 )
				end
			else
				error( "no such variable \"" .. tostring( k ) .. "\"", 2 )
			end
		end;
		obmeta.__tostring = function( )
			return object.name
		end;
		obmeta.__metatable = "SwiftClassObject";

		for k, v in pairs( objectmeta ) do
			obmeta["__" .. tostring( k )] = v
		end

		setmetatable( pb, obmeta )

		local c = object
		while true do
			if type( c.private[c.name] ) == "function" then
				return c.private[c.name]( ob, ... )
			end
			if c.extends then
				c = c.extends
			else
				break
			end
		end

		return pb

	end

	function public:type( full )
		local str = ""
		if full then
			local c = object.extends
			while c do
				str = c.name .. "." .. str
				c = c.extends
			end
		end
		return str .. object.name
	end

	function public:typeOf( other )
		if type( other ) == "table" then
			if getmetatable( other ) == "SwiftClass" then
				local ob = object
				while ob do
					if ob.class == other then
						return true
					end
					ob = ob.extends
				end
			end
		end
		return false
	end

	function public:extends( ob )
		ob:extend( object )
	end

	function public:extend( ob )
		setmetatable( ob.static, { __index = object.static } )
		setmetatable( ob.public, { __index = object.public } )
		setmetatable( ob.private, { __index = object.private } )
		ob.extends = object
	end

	local meta = { }
	meta.__index = function( _, k )
		if k == "static" then
			return setmetatable( { }, {
				__newindex = function( _, k, v )
					object.static[k] = v
				end;
				__metatable = { };
			} )
		elseif k == "public" then
			return setmetatable( { }, {
				__newindex = function( _, k, v )
					object.public[k] = {
						read = true;
						write = false;
						value = v;
					}
				end;
				__call = function( _, k )
					object.public[k] = {
						read = true;
						write = true;
						value = nil;
					}
					return function( _type )
						object.public[k].write = function( ob, value )
							if type( value ) == _type or class.typeOf( value, _type ) then
								ob[k] = value
							else
								if class.type( _type ) == "Class" then
									error( "expected " .. _type:type( ) .. " " .. k, 3 )
								else
									error( "expected " .. _type .. " " .. k, 3 )
								end
							end
						end
					end
				end;
				__index = function( _, k )
					if object.public[k] then
						return setmetatable( { }, {
							__newindex = function( _, name, v )
								if name == "read" then
									if type( v ) == "boolean" or type( v ) == "function" then
										object.public[k].read = v
									else
										error( "invalid modifier value", 2 )
									end
								elseif name == "write" then
									if type( v ) == "boolean" or type( v ) == "function" then
										object.public[k].write = v
									else
										error( "invalid modifier value", 2 )
									end
								else
									error( "invalid modifier name", 2 )
								end
							end;
							__metatable = { };
						} )
					else
						error( "public index " .. tostring( k ) .. " not found", 2 )
					end
				end;
				__metatable = { };
			} )
		elseif k == "meta" then
			return setmetatable( { }, {
				__index = function( _, k )
					if k == "index" then
						return customindex
					elseif k == "newindex" then
						return customnewindex
					else
						return objectmeta[k]
					end
				end;
				__newindex = function( _, k, v )
					if k == "metatable" then
						error( "cannot change this metamethod", 2 )
					elseif k == "index" then
						if type( v ) == "function" or type( v ) == "table" or v == nil then
							customindex = v
						else
							error( "cannot use type " .. type( v ) .. " for index metamethod", 2 )
						end
					elseif k == "newindex" then
						if type( v ) == "function" or type( v ) == "table" or v == nil then
							customnewindex = v
						else
							error( "cannot use type " .. type( v ) .. " for newindex metamethod", 2 )
						end
					else
						objectmeta[k] = v
					end
				end;
				__metatable = { };
			} )
		else
			return object.static[k]
		end
	end
	meta.__newindex = function( _, k, v )
		object.private[k] = v
	end;
	meta.__call = function( self, ... )
		return self:new( ... )
	end;
	meta.__totring = function( )
		return "Class"
	end;
	meta.__metatable = "SwiftClass"

	setmetatable( public, meta )

	return public
end

function class.public( name )
	local object = class.new( name )
	getfenv( )[name] = object
end

function class.type( object )
	if type( object ) == "table" then
		if getmetatable( object ) == "SwiftClass" then
			return "Class"
		end
		if getmetatable( object ) == "SwiftClassObject" then
			return object:type( )
		end
	end
	return type( object )
end

function class.typeOf( object, ... )
	local types = { ... }
	for i = 1, #types do
		if type( object ) == "table" and getmetatable( object ) == "SwiftClassObject" then
			if object:typeOf( types[i] ) then
				return types[i]
			end
		elseif type( object ) == "table" and getmetatable( object ) == "SwiftClass" then
			if types[i] == "Class" then
				return "Class"
			end
		else
			if type( object ) == types[i] then
				return types[i]
			end
		end
	end
	return false
end

setmetatable( class, { __call = function( _, ... ) return class.new( ... ) end } )
local args = { ... }
local global = getfenv( )
local custom = setmetatable( { class = class, ARGS = args }, { __index = global } )
function custom.export( variable, value )
	if custom[variable] ~= nil or value then
		global[variable] = custom[variable] == nil and value or custom[variable]
	end
end
local required = { }
local function require( file, ... )
	if not required[file] and files[file] then
		required[file] = true
		if files[file].meta.type == "class" then
			custom[file] = class( file )
		end
		local fenv = setmetatable( { }, { __index = custom } )
		local f, err = loadstring( files[file].content, file .. ".lua" )
		if f then
			setfenv( f, fenv )
			local ok, data = pcall( f )
			if ok then
				if files[file].meta.type == "lib" then
					if data ~= nil then
						custom[file] = data
						return data
					else
						local t = { }
						for k, v in pairs( fenv ) do
							t[k] = v
						end
						custom[file] = t
						return t
					end
				end
				return data
			else
				error( data, 0 )
			end
		else
			error( err, 0 )
		end
	end
end
custom.require = require

for i = 1, #autorun do
	require( autorun[i] )
end
